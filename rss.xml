<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>Weilet's blog</title><link>https://weilet.me/</link><description></description><lastBuildDate>Sun, 26 Apr 2020 23:17:00 +0800</lastBuildDate><item><title>《李银河说爱情》读后感</title><link>https://weilet.me/%E3%80%8A%E6%9D%8E%E9%93%B6%E6%B2%B3%E8%AF%B4%E7%88%B1%E6%83%85%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F</link><description>&lt;p&gt;大多数人都是从王小波的书里知道李银河的，我也不例外。她作为一位社会学学者，《李银河说爱情》可以视作她多年研究的成果，十分适合作为爱情观婚姻观的启蒙读物。&lt;/p&gt;
&lt;p&gt;本书分为六大章。前四章，从婚姻制度的演化讲到爱情观的地域差别，再到与性相关的LGBT、性癖好等的讲解，行文都十分通俗易懂，挺开阔眼界的。后两章讲的就比较大，像男女平等，女性独立之类的话题。&lt;/p&gt;
&lt;p&gt;如果你持一个开放的态度去看本书，那你能了解到，这个世界的性爱观爱情观婚姻观远比你想象的丰富。然而如果你是个狭隘的人，估计看书的时候会被气得上蹿下跳。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Sun, 26 Apr 2020 23:17:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-04-26:/《李银河说爱情》读后感</guid><category>Book</category></item><item><title>劳动节随想</title><link>https://weilet.me/%E5%8A%B3%E5%8A%A8%E8%8A%82%E9%9A%8F%E6%83%B3</link><description>&lt;p&gt;​       五月一日，是国际劳动节，是为纪念1886年美国芝加哥劳工争取&lt;a href="https://zh.wikipedia.org/wiki/八小时工作制"&gt;八小时工作制&lt;/a&gt;而被警察武装镇压的&lt;a href="https://zh.wikipedia.org/wiki/干草市场事件"&gt;干草市场事件&lt;/a&gt;而设立的。&lt;/p&gt;
&lt;p&gt;​&amp;nbsp;戏谑的是，在今年的国际劳动节之日，国家地理杂志的微博居然发布了一套包含黑人采摘棉花在内的“致敬劳动者”组图。黑人摘棉花是剥削的象征，与反对剥削的国际劳动节本意实在不符。同样戏谑的是，由于疫情影响，在艰难的就业环境下，有许多互联网公司的员工不得不在劳动节假日“自愿加班”。不知道他们收到别人发送的“劳动节快乐”时，心里是何种感受呢？&lt;/p&gt;
&lt;p&gt;​&amp;nbsp;劳动最光荣，这句话有错吗？显然没有。但当他成为资本家压迫劳动者的口号时，它就成了凶器。是一把使人放弃学习时间的堕落之刃，是一个使人甘于平庸的麻木之镰，它使得每个劳动者从一个活生生的人类转变为为资本工作的机器，谋害着劳动者的生命。&lt;/p&gt;
&lt;p&gt;​&amp;nbsp;但现实是有许多的人无法摆脱超负荷工作的现状。因为他们的生存就依赖着这份工作，不能离开，也不敢离开。我大体同意“先有生存再有生活”这样的说法。所以如果你在当下不太乐观的就业环境下遭受到不公平的待遇，且你的资产累计不足以让你待业一到两年，那就先忍忍吧。否则，大胆地离开它，你的人生值得更好的工作。&lt;/p&gt;
&lt;p&gt;​&amp;nbsp;愿天下劳动者，在劳动节之日，都无需劳动。&lt;/p&gt;
&lt;p&gt;​   &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Sun, 26 Apr 2020 22:16:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-04-26:/劳动节随想</guid><category>Thought</category></item><item><title>学会阅读源码</title><link>https://weilet.me/%E5%AD%A6%E4%BC%9A%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81</link><description>&lt;p&gt;当你遇到一个问题，你会如何解决？&lt;/p&gt;
&lt;p&gt;是在聊天群组里提问，然后被插科打诨，忘记自己的目标？&lt;/p&gt;
&lt;p&gt;还是自食其力，选择面向搜索引擎，费九牛二虎之力解决？&lt;/p&gt;
&lt;p&gt;自食其力是好事，然而面对开源项目时，直奔它的文档或者源代码是个缩小范围的好主意。&lt;/p&gt;
&lt;h3 id="_1"&gt;例子一&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Linux 课上老师提到了 umask ，它是创建文件和文件夹时需要额外减去的权限值，在 Unix&amp;nbsp;下为022（WSL为000）课后有同学提出，按照老师的方法并不能得出答案。&lt;/p&gt;
&lt;p&gt;那么正确的计算是什么呢？答案在 linux&amp;nbsp;源码中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// snippet from dir.c &lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;fc&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;dont_mask&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;current_umask&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// snippet from fs_struct.c&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;current_umask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;umask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从代码可以看出，mode 是 &lt;code&gt;&amp;amp;&lt;/code&gt; 上 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Wed, 08 Apr 2020 01:27:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-04-08:/学会阅读源码</guid><category>Tech</category></item><item><title>网站适配暗色模式</title><link>https://weilet.me/%E7%BD%91%E7%AB%99%E9%80%82%E9%85%8D%E6%9A%97%E8%89%B2%E6%A8%A1%E5%BC%8F</link><description>&lt;h3 id="_1"&gt;起因&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;鉴于目前无论是 iOS 还是 Android&amp;nbsp;都在推行暗色模式，因此我也一直在想办法将我的网站适配暗色模式，好让各位看官的眼睛不被亮瞎。&lt;/p&gt;
&lt;h3 id="-javascript"&gt;方案一 - JavaScript实现&lt;a class="headerlink" href="#-javascript" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这是我最先想到的方案，首先为暗色模式编写一段样式，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;dark&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;posts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;simple&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;each&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;border-color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;transparent&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;dark&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;posts&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;each&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;border&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="kt"&gt;px&lt;/span&gt; &lt;span class="kc"&gt;solid&lt;/span&gt; &lt;span class="kc"&gt;transparent&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;border-bottom-color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;#303030&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;dark&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;posts&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;each&lt;/span&gt; &lt;span class="nt"&gt;h2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mh"&gt;#ccc&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些样式都是 .dark&amp;nbsp;元素的子元素。&lt;/p&gt;
&lt;p&gt;随后利用JavaScript判断时间，在&lt;strong&gt;我认为&lt;/strong&gt;需要暗色模式的时间为 body 添加 .dark 的&amp;nbsp;class …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Fri, 13 Mar 2020 22:20:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-03-13:/网站适配暗色模式</guid><category>Tech</category><category>Interaction</category><category>Front end</category></item><item><title>Rust with WebAssembly</title><link>https://weilet.me/Rust%20with%20WebAssembly</link><description>&lt;blockquote&gt;
&lt;p&gt;大人，时代变了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="about-wasm"&gt;About wasm&lt;a class="headerlink" href="#about-wasm" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;WebAssembly ，亦称 wasm ，是一种基于浏览器的虚拟机的代码。由于它是二进制的，因此机器能够较快的执行。wasm 目前不能直接编写，它可以由 C/C++/Rust 生成。目前，Chrome 、 Microsoft Edge 、 Firefox 、 Safari 支持&amp;nbsp;wasm。&lt;/p&gt;
&lt;h3 id="why-rust"&gt;Why Rust?&lt;a class="headerlink" href="#why-rust" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我在学习 Rust ，Rust&amp;nbsp;是一门写起来很愉快的语言。&lt;/p&gt;
&lt;h3 id="_1"&gt;准备&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="rust"&gt;安装Rust&lt;a class="headerlink" href="#rust" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.rust-lang.org/zh-CN/tools/install"&gt;Rust官网&lt;/a&gt;&lt;/p&gt;
&lt;h4 id="wasm-pack"&gt;安装wasm-pack&lt;a class="headerlink" href="#wasm-pack" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://rustwasm.github.io/wasm-pack/installer/"&gt;Rustwasm官网&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="_2"&gt;流程&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;新建项目&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;cargo new wasm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目录结构&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;
&lt;span class="err"&gt;├── Cargo.toml&lt;/span&gt;
&lt;span class="err"&gt;└── src&lt;/span&gt;
&lt;span class="err"&gt;    └── lib.rs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;添加依赖&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[dependencies]&lt;/span&gt;
&lt;span class="n"&gt;wasm-bindgen …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Tue, 10 Mar 2020 05:09:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-03-10:/Rust with WebAssembly</guid><category>Tech</category><category>Rust</category><category>wasm</category></item><item><title>安装spf13-vim</title><link>https://weilet.me/%E5%AE%89%E8%A3%85spf13-vim</link><description>&lt;blockquote&gt;
&lt;p&gt;spf13-vim之于vim，恰如oh-my-zsh之于zsh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;背景&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;由于课程需要，我需要（真正地）使用vim这一编辑器。鉴于“颜值即是第一生产力的说法”，我是无法在黑黑丑丑的界面下写代码滴。其实在去年我就开始折腾vim的外观配置，然而由于艺术天赋有限而艺术追求无限的缘故，最终放弃。直到前几天我发现了&lt;a href="https://github.com/spf13/spf13-vim"&gt;spf13-vim&lt;/a&gt;这个好东西，当然是赶紧装上体验一番啦！&lt;/p&gt;
&lt;h3 id="_2"&gt;准备&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;spf13-vim需要vim with&amp;nbsp;lua，因为它有些插件是用lua编写的。&lt;/p&gt;
&lt;p&gt;查看是否支持lua&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vim --version &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; grep &lt;span class="s2"&gt;&amp;quot;+lua&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;&amp;amp;;&lt;/span&gt;&lt;span class="k"&gt;then&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Vim with lua&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Vim witho&lt;/span&gt;
&lt;span class="s2"&gt;ut lua&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果不支持需要安装&lt;code&gt;vim-nox&lt;/code&gt;（安装什么取决于你的图形环境：&lt;a href="https://github.com/Shougo/neocomplete.vim#debian-or-ubuntu"&gt;详情&lt;/a&gt;）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install vim-nox
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_3"&gt;安装&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;根据官方文档直接安装&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;curl https …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Tue, 03 Mar 2020 23:25:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-03-03:/安装spf13-vim</guid><category>Tech</category><category>Linux</category></item><item><title>谈谈Python中的for循环（2）</title><link>https://weilet.me/%E8%B0%88%E8%B0%88Python%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%882%EF%BC%89</link><description>&lt;blockquote&gt;
&lt;p&gt;总忘记for语句的原理，属文记之&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;前置知识&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="_2"&gt;作用域&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Python中的for循环并没有引入作用域(scope)的概念，但函数定义有引入作用域。&lt;/p&gt;
&lt;h4 id="legb"&gt;LEGB法则&lt;a class="headerlink" href="#legb" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;python中变量的搜索按照以下路径进行：&lt;/p&gt;
&lt;p&gt;本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing&amp;nbsp;locals）→全局/模块作用域（Global）→内置作用域（Built-in）&lt;/p&gt;
&lt;h4 id="_3"&gt;引用计数机制&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Python语言默认采用引用计数机制垃圾回收机制，当对象的引用计数为0时会被回收。默认创建的对象引用计数永不为0&lt;/p&gt;
&lt;h3 id="_4"&gt;&lt;a class="headerlink" href="#_4" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="for"&gt;for循环变量在外部的状态&lt;a class="headerlink" href="#for" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看上去会抛出异常，然而事实上它运作正常。&lt;/p&gt;
&lt;p&gt;我们用前置知识去解释它：&lt;/p&gt;
&lt;p&gt;首先由于for没有作用域的概念，所以全局的x的会得到for循环中最后的值。&lt;/p&gt;
&lt;p&gt;因为x为默认创建的对象（常量为解释器默认创建的对象），它当然不会被回收，所以的确存在。因此最终的print(x)能够运作并打印出10。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Wed, 26 Feb 2020 22:25:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-02-26:/谈谈Python中的for循环（2）</guid><category>Tech</category><category>Python</category></item><item><title>谈谈Python中的for循环（1）</title><link>https://weilet.me/%E8%B0%88%E8%B0%88Python%E4%B8%AD%E7%9A%84for%E5%BE%AA%E7%8E%AF%EF%BC%881%EF%BC%89</link><description>&lt;blockquote&gt;
&lt;p&gt;总忘记for语句的原理，属文记之&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;前置知识&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="_2"&gt;可迭代对象&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;对于任何一个实现了 &lt;code&gt;__iter__&lt;/code&gt; 方法的对象，我们称之为可迭代对象&lt;/p&gt;
&lt;h4 id="_3"&gt;迭代器对象&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;当调用可迭代对象的 &lt;code&gt;__iter__&lt;/code&gt;方法，它会返回一个迭代器对象；&lt;/p&gt;
&lt;p&gt;迭代器对象是&lt;strong&gt;已经&lt;/strong&gt;实现了 &lt;code&gt;__next__&lt;/code&gt; 方法的对象&lt;/p&gt;
&lt;h4 id="stopiteration"&gt;StopIteration异常&lt;a class="headerlink" href="#stopiteration" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;当调用迭代器对象的 &lt;code&gt;__next__&lt;/code&gt; 方法而无下一个元素时，它会抛出StopIteration异常&lt;/p&gt;
&lt;h4 id="_4"&gt;魔法方法&lt;a class="headerlink" href="#_4" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;以双下划线开头和结尾的方法；&lt;/p&gt;
&lt;p&gt;一般而言，对于对象 &lt;code&gt;object_xyz&lt;/code&gt; 魔法方法 &lt;code&gt;__abc__&lt;/code&gt; ，其调用方式为abc(object_xyz)&lt;/p&gt;
&lt;h3 id="_5"&gt;整体流程&lt;a class="headerlink" href="#_5" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在上述前置知识和一定的python基础下，我们来看这段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;test_case&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c1"&gt;# A&lt;/span&gt;
&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_case&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iterator …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Tue, 25 Feb 2020 22:25:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-02-25:/谈谈Python中的for循环（1）</guid><category>Tech</category><category>Python</category></item><item><title>Windows Terminal折腾指南</title><link>https://weilet.me/Windows%20Terminal%E6%8A%98%E8%85%BE%E6%8C%87%E5%8D%97</link><description>&lt;blockquote&gt;
&lt;p&gt;终端是程序员的浪漫&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我从2017年年底开始接触终端这个概念，那时候我对它一知半解，是个被GUI宠坏的巨婴。&lt;/p&gt;
&lt;p&gt;直到后来，我碰见了&lt;a href="https://hyper.is/"&gt;Hyper&lt;/a&gt;，它的高颜值和高度定制使我沉迷。然而渐渐地我觉得它的速度比起原生的慢太多了。而且有些时候我需要切换PowerShell和WSL，它并不支持。&lt;/p&gt;
&lt;p&gt;能够打败原生的，只有原生。某天我在Django交流群里了解到&lt;a href="https://github.com/microsoft/terminal"&gt;Windows Terminal&lt;/a&gt;（下称Terminal），一番折腾，流畅的同时还能够多个shell切换，值得安利！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意：Windows Terminal需要Windows 10 1903或更高版本&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="_1"&gt;预备&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我假设你是使用WSL的：&lt;/p&gt;
&lt;p&gt;首先，开启WSL功能（Cortana里搜索功能，一溜儿找下来）&lt;/p&gt;
&lt;p&gt;然后，在Microsoft&amp;nbsp;Store找到你喜欢的发行版（比如我就喜欢Ubuntu）安装&lt;/p&gt;
&lt;h3 id="_2"&gt;安装&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="microsoft-store"&gt;Microsoft Store&lt;a class="headerlink" href="#microsoft-store" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;最简单的方法，目前使用下来没有任何问题。&lt;/p&gt;
&lt;h4 id="_3"&gt;自行编译&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/terminal#manually-installing-builds-from-this-repository"&gt;官方文档&lt;/a&gt;请。大哥都选择自行编译了，看看文档肯定会。&lt;/p&gt;
&lt;h4 id="chocolatey"&gt;Chocolatey&lt;a class="headerlink" href="#chocolatey" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;choco install microsoft-windows-terminal …&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Fri, 14 Feb 2020 22:25:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-02-14:/Windows Terminal折腾指南</guid><category>Tech</category><category>Windows</category><category>Terminal</category></item><item><title>新的钢笔</title><link>https://weilet.me/%E6%96%B0%E7%9A%84%E9%92%A2%E7%AC%94</link><description>&lt;blockquote&gt;
&lt;p&gt;年前朋友送了一支凌美演绎，用到现在也快两周了，说说体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;流畅性&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我之前买过一支百乐的78G，使用后惊叹于日式钢笔的顺滑。同时我还试用过同学的狩猎者。一直觉得凌美的钢笔虽然容易出锋但是真的很涩。但实际上，演绎比狩猎者要顺滑很多，而且还是一样容易出锋。&lt;/p&gt;
&lt;h3 id="_2"&gt;舒适性&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;金属笔杆很滑很舒服。如果把笔帽盖到后面会有点重，我不喜欢。目前只它用来写小抄和做手帐，不知道大书写量下会不会累人。&lt;/p&gt;
&lt;h3 id="_3"&gt;美观性&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我这支是纯黑的，我觉得普通但有质感。网上看蓝色和白金色很好看，但是既然是送的也就不奢求这么多啦。&lt;/p&gt;
&lt;h3 id="_4"&gt;便捷性&lt;a class="headerlink" href="#_4" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;上墨只需三步：旋开笔，换墨囊，旋回笔。等送的墨囊用完了还是用墨水吧，虽然麻烦一点，但一罐百乐ink30可以用三四个月，比墨囊划算。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Fri, 07 Feb 2020 19:42:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-02-07:/新的钢笔</guid><category>Unboxing</category><category>Pen</category></item><item><title>Python3.8新特性</title><link>https://weilet.me/Python3.8%E6%96%B0%E7%89%B9%E6%80%A7</link><description>&lt;h3 id="_1"&gt;&lt;a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#assignment-expressions"&gt;海象运算符&lt;/a&gt;&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我期待很久的特性，可以在表达式内赋值&lt;/p&gt;
&lt;p&gt;先前的写法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;{len(a)}&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在的写法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="sa"&gt;f&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;{n}&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;明显减少了一次len()函数的调用，当然可读性会稍有下降。&lt;/p&gt;
&lt;h3 id="_2"&gt;&lt;a href="https://docs.python.org/zh-cn/3.8/whatsnew/3.8.html#positional-only-parameters"&gt;仅限位置形参&lt;/a&gt;&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# do something&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;形参位置的“/”前为仅限位置形参，后为关键字形参。&lt;/p&gt;
&lt;p&gt;所谓仅限位置形参，就是你不能通过指定关键字去给它赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设我们常用的sort()函数的形参全为仅限位置形参，那么下面这种写法是错的&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kc"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;# THIS IS WRONG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目前来看 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Weilet</dc:creator><pubDate>Thu, 06 Feb 2020 21:46:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2020-02-06:/Python3.8新特性</guid><category>Tech</category><category>Python</category></item><item><title>CPP内存泄漏</title><link>https://weilet.me/CPP%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F</link><description>&lt;blockquote&gt;
&lt;p&gt;C++的内存管理太难了&lt;/p&gt;
&lt;p&gt;——鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="virtual"&gt;基类析构函数为非virtual&lt;a class="headerlink" href="#virtual" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基类的析构函数如果是非virtual的，那么上转型时，基类的析构函数不会被覆盖。这样子，属于子类的部分在析构时就不会会删除，导致内存泄漏。&lt;/p&gt;
&lt;h3 id="_1"&gt;依赖用户释放对象&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;依赖用户使用delete来释放内存，如果在释放过程前抛出异常，那么这部分的内存就不会被释放，导致内存泄漏。&lt;/p&gt;
&lt;p&gt;一个足够鲁棒的做法是，返回一个shared_ptr来管理原生对象。shared_ptr是个神奇的玩意，但你记得要为对象创建合适的shared_ptr。&lt;/p&gt;
&lt;h3 id="new-delete"&gt;New 和 Delete 不对称&lt;a class="headerlink" href="#new-delete" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;New&amp;nbsp;一组对象，却只delete一个对象，这样不内存泄漏真的没天理&lt;/p&gt;
&lt;h3 id="_2"&gt;未定义复制构造函数而成员中有指针变量&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这会导致调用默认复制构造函数然后使得同一个地址被两个指针所指（复制和被复制对象的指针变量），导致同一位置的内存被释放两次。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你以为大家看不出这是《effective&amp;nbsp;C++》的书摘吗?&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Fri, 25 Oct 2019 18:17:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-10-25:/CPP内存泄漏</guid><category>Tech</category><category>C</category><category>CPP</category></item><item><title>《SQL必知必会》书摘</title><link>https://weilet.me/%E3%80%8ASQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E4%B9%A6%E6%91%98</link><description>&lt;blockquote&gt;
&lt;p&gt;两天读完一本书，成就感满满，下面直接开始书摘，可能含有本人的一些理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="_1"&gt;主键相关&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;主键唯一非空且&lt;strong&gt;不可重用&lt;/strong&gt;，其实对&lt;strong&gt;不可重用&lt;/strong&gt;的理解不是很到位，日常开发中删除文章的id会重新赋给新建的文章。&lt;/p&gt;
&lt;h4 id="_2"&gt;逻辑操作相关&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;AND计算次序比OR更高，这点和编程语言一样，所以就算是为了可读性，也要常加括号。&lt;/p&gt;
&lt;p&gt;IN比OR的效率更高，且大多数情况下还比较简洁。&lt;/p&gt;
&lt;p&gt;NOT在复杂子句中提高可读性&lt;/p&gt;
&lt;h4 id="_3"&gt;通配符相关&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Access与其他数据库有很多不同，使用时记得查阅其文档&lt;/p&gt;
&lt;p&gt;通配符虽然使查找变得简单，但也导致查询时间变长&lt;/p&gt;
&lt;h4 id="_4"&gt;联结、子查询相关&lt;a class="headerlink" href="#_4" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;为聚集函数的结果取个别名是个好习惯&lt;/p&gt;
&lt;p&gt;自联结速度优于子查询&lt;/p&gt;
&lt;p&gt;并非所有DBMS都支持全外联结&lt;/p&gt;
&lt;h4 id="_5"&gt;增删查改相关&lt;a class="headerlink" href="#_5" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;INTO不要省略，即便你的DBMS允许你省略&lt;/p&gt;
&lt;p&gt;&lt;span class="caps"&gt;TRUNCATE&lt;/span&gt;&amp;nbsp;TABLE比DETELE速度快，因为它不会记录改变&lt;/p&gt;
&lt;h4 id="_6"&gt;高级操作相关&lt;a class="headerlink" href="#_6" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;每次使用视图都会执行一次查询，性能会降低&lt;/p&gt;
&lt;p&gt;请在使用视图嵌套后测试其性能&lt;/p&gt;
&lt;p&gt;事务管理时创建合适粒度的储存点会使你的ROLLBACK更灵活&lt;/p&gt;
&lt;p&gt;约束比触发器速度更快&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;别漏where&lt;/p&gt;
&lt;p&gt;别漏where&lt;/p&gt;
&lt;p&gt;别漏where&lt;/p&gt;
&lt;p&gt;重要的事情说三遍。&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Mon, 14 Oct 2019 18:22:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-10-14:/《SQL必知必会》书摘</guid><category>Tech</category><category>DataBase</category></item><item><title>学校教务系统爬取计划</title><link>https://weilet.me/%E5%AD%A6%E6%A0%A1%E6%95%99%E5%8A%A1%E7%B3%BB%E7%BB%9F%E7%88%AC%E5%8F%96%E8%AE%A1%E5%88%92</link><description>&lt;blockquote&gt;
&lt;p&gt;本文以一名高校学子的身份，向你展示爬取一个垃圾教务系统是何种体验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自从学校换了教务系统以后，旧的教务系统不再维护，不得以只能自己做一个推送系统。题外话，这新教务系统是真的烂啊。&lt;/p&gt;
&lt;h4 id="_1"&gt;需求分析&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;因为是自己用的，所以只需要简单爬取后再通过STMP或者wxpy进行推送，一个简单的课程推送系统就完成了。 当然，后来我发现“简单爬取”可一点都不简单。&amp;nbsp;鉴于在图书馆进行开发，我提前将敏感信息存进了一个叫config字典里，这样使用敏感信息的时候就不会被看到了。&lt;/p&gt;
&lt;h4 id="requests"&gt;requests试水&lt;a class="headerlink" href="#requests" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;说到用Python写爬虫，我第一时间想到了requests。requests凭借它的易用性，虏获了万千“脚本男孩”的心。通过开发者工具简单分析了请求，得到了请求地址、请求信息格式、请求头。万事俱备，只差一POST。然而现实是，当我POST过去的时候，返回了405错误。明明直接用浏览器POST请求没有问题，但用脚本却不行，也许是请求头出现了什么差错。&lt;/p&gt;
&lt;p&gt;在接近两个小时的尝试，我放弃了这个方法。&lt;/p&gt;
&lt;h4 id="selenium"&gt;selenium大法好&lt;a class="headerlink" href="#selenium" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;此计不成，我只好祭出selenium。利用selenium，我轻易地登陆了教务系统，但时间已经很晚，我打算把爬取信息的工作留到明天。&lt;/p&gt;
&lt;p&gt;第二天，你猜怎么着，由于selenium的特征被识别，我无法进入课表界面 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Wed, 25 Sep 2019 19:33:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-09-25:/学校教务系统爬取计划</guid><category>Tech</category><category>Python</category></item><item><title>如何安全地使用字典</title><link>https://weilet.me/%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E5%9C%B0%E4%BD%BF%E7%94%A8%E5%AD%97%E5%85%B8</link><description>&lt;blockquote&gt;
&lt;p&gt;安全地使用字典，和安全地使用套套一样重要&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python中的字典数据类型经常被用到，但当我们期待一个不存在的key的value时，它往往会带来一个异常，将我们的程序活生生终结，如何解决？&lt;/p&gt;
&lt;h4 id="_1"&gt;最开始的时候&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;当我们最初接触Python的时候，教学网站上面会跟你提到字典的get()方法。利用这个方法，可以安全地返回字典的值，如果对应的key不存在，那么它会返回一个默认值，这个&lt;strong&gt;默认值默认是None&lt;/strong&gt;，你也可以通过设置default的值改变这个默认值。&lt;/p&gt;
&lt;p&gt;需要注意的是，除了get()方法，setdefault()方法同样可以返回默认值，但setdefault()会将不存在的key的项追加到字典中，而get()不会。&lt;/p&gt;
&lt;h4 id="_2"&gt;笨拙且安全的&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;后来，我们学会了异常处理，于是或多或少出于炫技的目的，使用异常处理来完成这个任务。这个方法适合当出现KeyError，你不仅需要返回默认值，而且还需要做一些处理（不然为什么不使用简单的if-else呢？）&lt;/p&gt;
&lt;p&gt;可是，当你多年回来review你的代码，你也许会感叹它的笨拙。&lt;/p&gt;
&lt;h4 id="_3"&gt;是时候使用魔法的力量了&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;利用魔法方法（特殊方法）__missing__()，当key不存在时，字典会调用这个方法，而非抛出KeyError，很酷炫。&lt;/p&gt;
&lt;h4 id="_4"&gt;用些现成的&lt;a class="headerlink" href="#_4" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;鉴于collections中defaultdict的易用性，我向你强烈推荐 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sat, 21 Sep 2019 23:19:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-09-21:/如何安全地使用字典</guid><category>Tech</category><category>Python</category></item><item><title>浅谈CSRF攻击</title><link>https://weilet.me/%E6%B5%85%E8%B0%88CSRF%E6%94%BB%E5%87%BB</link><description>&lt;blockquote&gt;
&lt;p&gt;跨过山和大海，伪装成熟悉的陌生人&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="csrf"&gt;什么是CSRF&lt;a class="headerlink" href="#csrf" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class="caps"&gt;CSRF&lt;/span&gt;（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：&lt;span class="caps"&gt;CSRF&lt;/span&gt;/&lt;span class="caps"&gt;XSRF&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id="_1"&gt;有何危害&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;故事要从三天前说起，你是一个月薪3000的程序员，好不容易存够了20000打算更新自己的主机。&lt;/p&gt;
&lt;p&gt;这天你在网吧上网，想抽烟（抽烟有害健康）。于是你登陆账户，打算从里面取100大洋。与此同时，一个网页吸引你的注意，硕大的“屠龙宝刀，点击就送”使你情不自禁地点击。点进去以后，你发现跳出的居然是转账页面。定睛一看，转入的居然还不是你的账号，金额是一万。你两眼发昏，陷入沉思。&lt;/p&gt;
&lt;p&gt;为什么会发生这样的情况呢？我们来看看后台发生了什么：&lt;/p&gt;
&lt;p&gt;首先，你登陆进去以后，cookie里会储存一个你的登陆信息，告诉服务器，你登陆了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;flask&lt;/span&gt; &lt;span class="kn"&gt;import …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 04 Jun 2019 21:26:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-06-04:/浅谈CSRF攻击</guid><category>Tech</category><category>Web Security</category></item><item><title>哈希洪水攻击</title><link>https://weilet.me/%E5%93%88%E5%B8%8C%E6%B4%AA%E6%B0%B4%E6%94%BB%E5%87%BB</link><description>&lt;h3 id="_1"&gt;哈希洪水攻击的原理&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在各种常用的数据结构里，有些数据结构的“平均运行时间”和“最差运行时间”会差很远，比如&lt;strong&gt;哈希表（Hash Table）&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果这些元素的键（Key）极少出现相同哈希值，这项任务就只需O(n)的时间。&lt;/li&gt;
&lt;li&gt;如果这些键频繁出现相同的哈希值（频繁发生&lt;strong&gt;碰撞&lt;/strong&gt;），这项任务就需要O(n*n)的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;哈希洪水攻击就是利用哈希函数的特点，构造一些数据，使他们经过哈希函数处理后的值与原来的值产生冲突（相同），增加整个系统的时间开销。&lt;/p&gt;
&lt;h3 id="_2"&gt;如何攻击&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这里是一例&lt;a href="https://yq.aliyun.com/articles/92194#3"&gt;实验&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;没有实践过，个人理解的一种利用方法是，构建符合接口的、能够产生冲突的json串，经过jsondecode以后，json内部的数据会产生冲突，带来额外的开销。&lt;/p&gt;
&lt;p&gt;（如果理解错误，欢迎更正）&lt;/p&gt;
&lt;h3 id="_3"&gt;如何防御&lt;a class="headerlink" href="#_3" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;不能通过设置哈希函数的方式进行防御。如果知道哈希函数的实现时，只需要一点功夫就能够构造出一组频繁碰撞的键。&lt;/p&gt;
&lt;p&gt;但是，你可以：&lt;/p&gt;
&lt;p&gt;所以，我们应当&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;限制参数个数 …&lt;/li&gt;&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Wed, 29 May 2019 00:55:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-05-29:/哈希洪水攻击</guid><category>Tech</category><category>Web Security</category></item><item><title>Python中的GIL</title><link>https://weilet.me/Python%E4%B8%AD%E7%9A%84GIL</link><description>&lt;blockquote&gt;
&lt;p&gt;人们只瞧见了上帝关了门，却没瞅到上帝也开了窗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="gil"&gt;什么是GIL？&lt;a class="headerlink" href="#gil" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class="caps"&gt;GIL&lt;/span&gt;&lt;/strong&gt;即&lt;strong&gt;全局解释器锁&lt;/strong&gt;（英语：Global Interpreter Lock，缩写&lt;strong&gt;&lt;span class="caps"&gt;GIL&lt;/span&gt;&lt;/strong&gt;），是&lt;a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80"&gt;计算机程序设计语言&lt;/a&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E9%87%8A%E5%99%A8"&gt;解释器&lt;/a&gt;用于&lt;a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5"&gt;同步&lt;/a&gt;&lt;a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B"&gt;线程&lt;/a&gt;的一种机制，它使得任何时刻仅有一个线程在执行。即便在&lt;a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%A0%B8%E5%BF%83%E8%99%95%E7%90%86%E5%99%A8"&gt;多核心处理器&lt;/a&gt;上，使用 &lt;span class="caps"&gt;GIL&lt;/span&gt;&amp;nbsp;的解释器也只允许同一时间执行一个线程。&lt;/p&gt;
&lt;p&gt;From &lt;a href="https://zh.wikipedia.org/zh-hans/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"&gt;wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么需要GIL呢？网上很多博客都说是历史遗留问题。但实际上，我认为这和Python的内存管理机制有关。在Python中，每个对象都维护着一个引用计数，而当这个计数变为0时，这个对象将会被回收。如果没有GIL，两个进程对同一个对象的引用计数的更改就会导致错误，这里举个例子：&lt;/p&gt;
&lt;p&gt;进程X删除对象A使得其引用计数减1变为0，对象A被回收。进程Y删除对象A，这本报错的。但由于没有GIL，这两个进程同时进行，所以没有报错。这是错误的。&lt;/p&gt;
&lt;p&gt;因此，GIL的重要性不言而喻。但也是因为它 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Thu, 23 May 2019 00:07:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-05-23:/Python中的GIL</guid><category>Tech</category><category>Python</category></item><item><title>Python参数传递的问题</title><link>https://weilet.me/Python%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%9A%84%E9%97%AE%E9%A2%98</link><description>&lt;blockquote&gt;
&lt;p&gt;传参不规范，亲人两行泪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Python中的参数传递并非传值也非传引用，传的是对象的引用。&lt;/p&gt;
&lt;p&gt;这是一个结论，如果想要知道更多的细节，请阅读&lt;a href="https://book.douban.com/subject/25910544/"&gt;《编写高质量代码：改善Python程序的91个建议》&lt;/a&gt;的第31条建议。&lt;/p&gt;
&lt;p&gt;在Python里面，我们接触到的所有数据类型都是对象，包括常数和字符串。&lt;/p&gt;
&lt;p&gt;假设有下面代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ichxx&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当a传递给x时，它对应的内存模型是这样的&lt;/p&gt;
&lt;p&gt;&lt;img alt="示意图1" class="wp-image-435" src="https://l3away.cn/wp-content/uploads/2019/05/未命名文件-1.png" /&gt;&lt;/p&gt;
&lt;p&gt;当切片时，产生了新的字符串，此时内存模型变为：&lt;/p&gt;
&lt;p&gt;&lt;img alt="示意图2" class="wp-image-436" src="https://l3away.cn/wp-content/uploads/2019/05/未命名文件-2.png" /&gt;&lt;/p&gt;
&lt;p&gt;现在，a与x就没有关联了，自然对x的更改就不会反馈到a了&lt;/p&gt;
&lt;p&gt;那么，什么样的改变会反馈到实参呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在函数中，对可变对象的修改会反馈到对象本身，而对不可变对象的修改则不会&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以把变量名理解成标签，对象理解成商品，我们通过标签去寻找商品。当可变对象修改时，我们通过标签寻找的东西也就相应改变。而不可变对象不可变，所以我们只能把标签撕下来贴到别的商品上面，这样我们也能实现“改变寻找到的东西 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sat, 11 May 2019 10:31:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-05-11:/Python参数传递的问题</guid><category>Tech</category><category>Python</category></item><item><title>序列化Python对象</title><link>https://weilet.me/%E5%BA%8F%E5%88%97%E5%8C%96Python%E5%AF%B9%E8%B1%A1</link><description>&lt;h3 id="_1"&gt;什么是序列化&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;(Serialization)&lt;strong&gt;是&lt;/strong&gt;将对象的状态信息转换为可以存储或传输的形式的过程。 在&lt;strong&gt;序列化&lt;/strong&gt;期间，对象将其当前状态写入到临时或持久性存储区。 以后，可以通过从存储区中读取或反&lt;strong&gt;序列化&lt;/strong&gt;对象的状态，重新创建该对象。&lt;/p&gt;
&lt;p&gt;来自百度百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_2"&gt;为什么需要序列化&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;便于传输&lt;/p&gt;
&lt;h3 id="python"&gt;Python 中使用序列化&lt;a class="headerlink" href="#python" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="pickle"&gt;Pickle 模块&lt;a class="headerlink" href="#pickle" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Pickle是Python中一个常用的序列化模块，它有以下优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;易用&lt;/li&gt;
&lt;li&gt;支持多种数据类型&lt;/li&gt;
&lt;li&gt;维护引用关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是，它也有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非原子性&lt;/li&gt;
&lt;li&gt;不兼容别的语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说到底常用的就四个函数：dump，load，dumps，loads。&lt;/p&gt;
&lt;p&gt;还是直接看表演吧。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pickle&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;stu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Student&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stu …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Wed, 08 May 2019 22:11:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-05-08:/序列化Python对象</guid><category>Tech</category><category>Python</category></item><item><title>C 语言中的 extern 关键字</title><link>https://weilet.me/C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84extern%E5%85%B3%E9%94%AE%E5%AD%97</link><description>&lt;blockquote&gt;
&lt;p&gt;如果不是选择重新学习&amp;nbsp;C，我可能这辈子都不会碰到这个关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;extern&amp;nbsp;用于声明一个外部变量，这个变量在项目的其他地方定义过。&lt;/p&gt;
&lt;p&gt;假设有头文件&amp;nbsp;errno.h&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 test.c&amp;nbsp;中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;errno.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 声明外部变量&lt;/span&gt;
      &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 可以对外部变量进一步操作&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      一些操作&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的点是，如果你使用不止一个外部变量，你应当保证它们的名字都不一样。（不要试图仅凭类型区分两个外部变量！！！）&lt;/p&gt;
&lt;p&gt;在声明外部变量时，一般避免直接定义，即不要写成 &lt;strong&gt;extern int a = 0;&lt;/strong&gt;&amp;nbsp;的形式。&lt;/p&gt;
&lt;p&gt;这样的变量不能进一步修改，不能循环利用，出于环保的缘故我们应当趋避之 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Mon, 06 May 2019 15:48:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-05-06:/C语言中的extern关键字</guid><category>Tech</category><category>C</category><category>CPP</category></item><item><title>宏定义的常见的三种意外</title><link>https://weilet.me/%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%84%8F%E5%A4%96</link><description>&lt;h4 id="_1"&gt;宏拓展后的大小可能超乎你的想象&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;这一点没想到例子，以后碰到再补充&lt;/p&gt;
&lt;h4 id="_2"&gt;对参数的捆绑不如函数严实，会导致意料之外的结果&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;很常见的一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define square(x) x*x&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编写一个宏，计算 x&amp;nbsp;的平方。&lt;/p&gt;
&lt;p&gt;看上去这段代码没有错，我们得到的答案将会是&amp;nbsp;25。&lt;/p&gt;
&lt;p&gt;实际上呢，我们得到的答案是&amp;nbsp;11。&lt;/p&gt;
&lt;p&gt;为什么呢？我们将square(x+1)展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 30 Apr 2019 16:20:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-30:/宏定义的常见的三种意外</guid><category>Tech</category><category>C</category><category>CPP</category></item><item><title>C 语言下多重嵌套的define</title><link>https://weilet.me/C%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E7%9A%84define</link><description>&lt;p&gt;有以下一段宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _STR(x) _VAL(x)&lt;/span&gt;
&lt;span class="cp"&gt;#define _VAL(x) #x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原以为只是 define _VAL(x) #x 起效果，并不清楚 define _STR(x) _VAL(x)&amp;nbsp;的作用。&lt;/p&gt;
&lt;p&gt;因为使用 int x = 5 去测试，发现无论是 _STR() 还是 _VAL() 都是输出&amp;nbsp;x&lt;/p&gt;
&lt;p&gt;后来发现，如果改为在顶部添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define x 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;_STR() 的值为 &amp;#8220;100&amp;#8221; 而 _VAL()的值为&amp;nbsp;&amp;#8220;x&amp;#8221;&lt;/p&gt;
&lt;p&gt;由此可以得知，所谓的 define _STR …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sun, 28 Apr 2019 13:47:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-28:/C语言下多重嵌套的define</guid><category>Tech</category><category>C</category><category>CPP</category></item><item><title>良性取消定义</title><link>https://weilet.me/%E8%89%AF%E6%80%A7%E5%8F%96%E6%B6%88%E5%AE%9A%E4%B9%89</link><description>&lt;p&gt;在 C 标准库里面，\&amp;lt;assert.h&gt; 中有一段这样的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#undef assert&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef NDEBUG&lt;/span&gt;
&lt;span class="cp"&gt;#define assert (test) ((void)0)&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="cp"&gt;#define assert (test) ...&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里面第一行就是 &lt;strong&gt;良性取消定义&lt;/strong&gt;，它是用来保证先前已经 define 的 assert 不会影响接下来的 assert。如果先前没有 define assert，那么这个语句也不会产生任何副作用。当使用一些可变的定义时，&lt;strong&gt;良性取消定义&lt;/strong&gt;是必要的。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sat, 27 Apr 2019 22:45:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-27:/良性取消定义</guid><category>Tech</category><category>C</category><category>CPP</category></item><item><title>Python中多继承的顺序问题</title><link>https://weilet.me/Python%E4%B8%AD%E5%A4%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98</link><description>&lt;h3 id="_1"&gt;从左到右&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;say&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;I am a A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;say&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;I am a B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;say&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# I am a A&lt;/span&gt;
&lt;span class="c1"&gt;# 搜索过程如下，先搜索A，A中有say …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 23 Apr 2019 22:47:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-23:/Python中多继承的顺序问题</guid><category>Tech</category><category>Python</category><category>OOP</category></item><item><title>Python中的Mixin模式</title><link>https://weilet.me/Python%E4%B8%AD%E7%9A%84Mixin%E6%A8%A1%E5%BC%8F</link><description>&lt;h3 id="mixin"&gt;什么是Mixin&lt;a class="headerlink" href="#mixin" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Mixin是面向对象程序设计语言中的类，提供了方法的实现。&lt;/p&gt;
&lt;h3 id="mixin_1"&gt;为什么需要 Mixin&lt;a class="headerlink" href="#mixin_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;[首先我们需要明白，Python 中是支持多继承的。那么，你可能会问，既然 Python 支持多继承，那多继承和 使用 Mixin 有什么不同呢？]{.md-plain} [从逻辑角度上看，多继承混淆了子类的属性，继承关系应当是 is-a 的关系的，至于其他多余的、不能从父类获取，应当利用其他方法去添加。]{.md-plain} [在 Java 中，interface 解决了这个问题。一个类继承了父类后，如果需要其他属性，可以通过实现接口来解决。这使得代码的可读性变强。]{.md-plain} [同样，在 Python 中，只有一个父类，至于继承的 Mixin，只是提供了方法的实现。它的名字应当是这样的&amp;nbsp;NameMixin，而且它应该具备以下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先它必须表示某一种功能，而不是某个物品 …&lt;/li&gt;&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Mon, 22 Apr 2019 10:12:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-22:/Python中的Mixin模式</guid><category>Tech</category><category>Python</category><category>OOP</category></item><item><title>两个下划线和Python的故事</title><link>https://weilet.me/%E4%B8%A4%E4%B8%AA%E4%B8%8B%E5%88%92%E7%BA%BF%E5%92%8CPython%E7%9A%84%E6%95%85%E4%BA%8B</link><description>&lt;blockquote&gt;
&lt;p&gt;从前，有两个孤独的下划线，走进了 Python&amp;nbsp;的世界&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;魔法方法&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;是的，他们不幸地进入了面向对象编程的世界，并成为了魔法方法中的一部分。&lt;/p&gt;
&lt;p&gt;在 Python&amp;nbsp;的世界里面，有以下常见的魔法方法：&lt;/p&gt;
&lt;p&gt;1. __init__&amp;nbsp;初始化对象时会被调用&lt;/p&gt;
&lt;p&gt;2. __del__&amp;nbsp;对象释放时会被调用&lt;/p&gt;
&lt;p&gt;3. __new__&amp;nbsp;对象被创建时会被调用；注意，创建的时机早于初始化&lt;/p&gt;
&lt;p&gt;4. __str__&amp;nbsp;使用print()时会被调用&lt;/p&gt;
&lt;p&gt;5. __len__&amp;nbsp;使用len()时会被调用&lt;/p&gt;
&lt;p&gt;6. __call__&amp;nbsp;将对象当作函数使用时会被调用&lt;/p&gt;
&lt;p&gt;7. __add__, __sub__, __mul__, __div__&amp;nbsp;加、减、乘、除时会被调用&lt;/p&gt;
&lt;p&gt;8. __mod__, __pow__&amp;nbsp;取模、求幂时会被调用&lt;/p&gt;
&lt;p&gt;9 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 16 Apr 2019 12:38:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-04-16:/两个下划线和Python的故事</guid><category>Tech</category><category>Python</category></item><item><title>Python函数注释</title><link>https://weilet.me/Python%E5%87%BD%E6%95%B0%E6%B3%A8%E9%87%8A</link><description>&lt;p&gt;相较于以往采用文档字符串去注释函数，现在 Python&amp;nbsp;提供了更为轻便的，为小型功能函数准备的函数注释功能。&lt;/p&gt;
&lt;h3 id="_1"&gt;如何添加函数注释&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在参数后添加英文半角冒号，注释类型&lt;br /&gt;
在函数定义括号后使用一个连字符和右尖括号，注释返回参数类型&lt;br /&gt;&amp;nbsp;下面是例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;age&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_2"&gt;注意&lt;a class="headerlink" href="#_2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;显然，这个类型可以是你瞎编的。但引入某些类型的注释时，需要引入 typing&amp;nbsp;中相应的模块，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然，你仍然可以给参数添加默认值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;typing&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sun, 03 Mar 2019 22:18:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2019-03-03:/Python函数注释</guid><category>Tech</category><category>Python</category></item><item><title>Jinja2模板引擎学习总结</title><link>https://weilet.me/jinja2%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93</link><description>&lt;h2 id="jinja2"&gt;Jinja2 模板引擎 学习&lt;a class="headerlink" href="#jinja2" title="Permanent link"&gt; &lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="_1"&gt;变量绑定&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;输出变量为 &lt;code&gt;name&lt;/code&gt; 的变量  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出对象 &lt;code&gt;user&lt;/code&gt; 中的变量名为 &lt;code&gt;name&lt;/code&gt; 的变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;user.name&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;user&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="if-else"&gt;if - else 选择语句&lt;a class="headerlink" href="#if-else" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;与其他语言的 if - else&amp;nbsp;语句并无太大区别&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;admin&amp;#39;&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&amp;gt;&lt;/span&gt;欢迎进入管理界面&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&amp;gt;&lt;/span&gt;欢迎你 &lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;name&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;span&amp;gt;&lt;/span&gt;需要登陆&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="for"&gt;for 循环&lt;a class="headerlink" href="#for" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意内置的loop&amp;nbsp;方法，非常好用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;后台爬取到广州各区的天气存储在 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sun, 28 Oct 2018 21:56:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-10-28:/jinja2模板引擎学习总结</guid><category>Tech</category><category>Python</category><category>jinja2</category></item><item><title>用Python，查快递</title><link>https://weilet.me/%E7%94%A8Python%EF%BC%8C%E6%9F%A5%E5%BF%AB%E9%80%92</link><description>&lt;p&gt;在剁手的同时练手&amp;nbsp;）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c1"&gt;# @Author: Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Date:   2018-08-07 01:31:50&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified by:   Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified time: 2018-08-07 06:17:13&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;requests&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;

&lt;span class="c1"&gt;#访问网页返回字典&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;visit_api&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;requests&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;result_dict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loads&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result_dict&lt;/span&gt;

&lt;span class="c1"&gt;#返回公司编号&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_company&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epnum&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;http …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 07 Aug 2018 06:18:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-08-07:/用Python，查快递</guid><category>Tech</category><category>Python</category></item><item><title>用crontab配置定时任务</title><link>https://weilet.me/%E7%94%A8crontab%E9%85%8D%E7%BD%AE%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1</link><description>&lt;p&gt;前段时间需要定期把一个服务器上的日志以邮件的形式发送到我的邮箱，于是了解了一下linux下定时任务的实现。&lt;/p&gt;
&lt;p&gt;（本文假定阅读者有基本的linux操作能力）&lt;/p&gt;
&lt;p&gt;linux下一般用crontab配置定时任务，本人用的是centos。&lt;/p&gt;
&lt;p&gt;安装命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;yum install vixie-cron #cron主程序&lt;/span&gt;
&lt;span class="err"&gt;yum install crontab #crontab主体&lt;/span&gt;
&lt;span class="err"&gt;chkconfig -level 345 crond on #设置开机自启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装成功后打开crontab&amp;nbsp;配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;vi /etc/crontab&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后 该文件布局如下（ &lt;strong&gt;注意，以编辑crontab的方式运行定时任务不能省略用户名&lt;/strong&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;m h d m weekday user  command&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对应的分别是：&lt;/p&gt;
&lt;p&gt;分钟 小时 日期 月份 星期 用户&amp;nbsp;命令&lt;/p&gt;
&lt;p&gt;每个值的范围（不过不限制则为*）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;0-59 0-23 1-31 1-12 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Tue, 07 Aug 2018 06:09:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-08-07:/用crontab配置定时任务</guid><category>Tech</category><category>Linux</category></item><item><title>忘记root的密码如何解决</title><link>https://weilet.me/%E5%BF%98%E8%AE%B0ubuntu%E7%9A%84root%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3</link><description>&lt;blockquote&gt;
&lt;p&gt;昨天教同学使用Ubuntu，他居然把密码给忘记了。于是便顺便了解了一下这方面的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先是在开机3秒内按下ESC键&lt;/p&gt;
&lt;p&gt;然后就会出现一个菜单，选择进入恢复模式 （recovery&amp;nbsp;mode）&lt;/p&gt;
&lt;p&gt;进入恢复模式以后，启用root&amp;nbsp;shell&lt;/p&gt;
&lt;p&gt;将目录改为可写&lt;br /&gt;
&lt;code&gt;mount -o rw,remount&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看home下的用户&lt;br /&gt;
&lt;code&gt;ls /home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;修改密码&lt;br /&gt;
&lt;code&gt;passwd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入两次密码（一次是确认）即修改完成&lt;/p&gt;
&lt;p&gt;重启&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sun, 05 Aug 2018 22:47:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-08-05:/忘记ubuntu的root密码如何解决</guid><category>Tech</category><category>Linux</category></item><item><title>用Python给你女朋友写封信</title><link>https://weilet.me/%E7%94%A8Python%E7%BB%99%E4%BD%A0%E5%A5%B3%E6%9C%8B%E5%8F%8B%E5%86%99%E5%B0%81%E4%BF%A1</link><description>&lt;p&gt;喜欢木心先生的《从前慢》，那种一辈子只够爱一个人的闲适，被今日快节奏的生活方式打破。&lt;/p&gt;
&lt;p&gt;虽然今日邮件已然销声匿迹，但电子邮件的兴起给我们另一个选择。&lt;/p&gt;
&lt;p&gt;若怀念木心，不妨静下心来，在键盘上诚诚恳恳敲击你想对她诉说的，不也浪漫？不也悠长？&lt;/p&gt;
&lt;p&gt;那么，如何用Python写电子邮件呢？&lt;/p&gt;
&lt;p&gt;我们需要用到smtplib和email模块&lt;/p&gt;
&lt;p&gt;我们从简单的开始，写一首情诗送给她&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c1"&gt;# @Author: Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Date:   2018-07-12 05:56:46&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified by:   Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified time: 2018-07-13 13:29:09&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;smtplib&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;email.mime.text&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MIMEText&lt;/span&gt; &lt;span class="c1"&gt;#多媒体网际网路邮件延伸文本，即纯文本&lt;/span&gt;
&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;醉过才知酒浓，爱过才知情重。  &lt;/span&gt;
\&lt;span class="n"&gt;n你定是我的诗 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Sat, 14 Jul 2018 00:30:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-07-14:/用Python给你女朋友写封信</guid><category>Tech</category><category>Python</category></item><item><title>我的第一只爬虫</title><link>https://weilet.me/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E5%8F%AA%E7%88%AC%E8%99%AB</link><description>&lt;p&gt;寒假的时候学习了一下Python的爬虫，并将豆瓣电影排行榜爬取了下来&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c1"&gt;# @Author: Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Date:   2018-01-12 05:18:40&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified by:   Lily_Sun&lt;/span&gt;
&lt;span class="c1"&gt;# @Last Modified time: 2018-01-12 05:18:40&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;re&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;urllib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;

&lt;span class="n"&gt;cnt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;https://movie.douban.com/chart&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;req&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Thu, 12 Jul 2018 05:28:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-07-12:/我的第一只爬虫</guid><category>Tech</category><category>Python</category></item><item><title>快速幂和矩阵快速幂</title><link>https://weilet.me/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%92%8C%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82</link><description>&lt;p&gt;快速幂，顾名思义就是快速求幂的算法。原理如下：&lt;/p&gt;
&lt;p&gt;假设求a的n次方，当n为偶数时，a的n次方可以由两个a的n/2次方相乘求得；当n为奇数时，a的n次方可以由两个a的n/2次方相乘的积再乘以a得到。&lt;/p&gt;
&lt;p&gt;在实现中，运用位运算判断奇偶和乘除2（第一个想到的简直就是天才）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="nf"&gt;quick_pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;degree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;degree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;degree&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;ans&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;degree&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ans&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cin&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Thu, 12 Jul 2018 03:08:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-07-12:/快速幂和矩阵快速幂</guid><category>Tech</category><category>Algorithm</category></item><item><title>图片隐写套路</title><link>https://weilet.me/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99%E5%A5%97%E8%B7%AF</link><description>&lt;h3 id="_1"&gt;总结一些图片隐写术的套路&lt;a class="headerlink" href="#_1" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;h3 id="0x000-exif"&gt;0x000 exif&lt;a class="headerlink" href="#0x000-exif" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Windows下直接右键属性查看就好，有些题目会用Base64等方式加密，不过也就一梭子代码的问题。&lt;/p&gt;
&lt;p&gt;Linux下用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;identify -verbose filename
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="0x001"&gt;0x001 隐藏文件&lt;a class="headerlink" href="#0x001" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;文件的隐藏利用
 &lt;code&gt;shell
copy /b 2.jpg+1.zip output.jpg&lt;/code&gt;
对于这类题目，用binwalk分析后用dd命令分解出来就好：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;filename &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;filename &lt;span class="nv"&gt;skip&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;start_point_of_hidden_file &lt;span class="nv"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;                          
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="0x010-lsb"&gt;0x010 &lt;span class="caps"&gt;LSB&lt;/span&gt; 修改&lt;a class="headerlink" href="#0x010-lsb" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;直接用stegsolve看通道，一般会隐藏二维码在其中。&lt;/p&gt;
&lt;h3 id="0x011"&gt;0x011 查看其他信息&lt;a class="headerlink" href="#0x011" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Windows下把图片拖进WinHex，缺少文件头的话补全。在文件结尾后有一段不明字符串，可以尝试解码。&lt;/p&gt;
&lt;p&gt;拖进Stegsolve里查看附着的信息，有可能有ascii形式的Flag。&lt;/p&gt;
&lt;h3 id="0x100"&gt;0x100 双图&lt;a class="headerlink" href="#0x100" title="Permanent link"&gt; &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目前做过的题目的解决方案是拖进stegsolve里边然后选择图片叠加。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">PwnForWhat</dc:creator><pubDate>Mon, 09 Jul 2018 23:35:00 +0800</pubDate><guid isPermaLink="false">tag:weilet.me,2018-07-09:/图片隐写套路</guid><category>Tech</category><category>CTF</category><category>MISC</category></item></channel></rss>