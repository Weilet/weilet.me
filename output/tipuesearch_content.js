var tipuesearch = {"pages":[{"title":"C++内存泄漏的一些点","text":"C++的内存管理太难了 ——鲁迅 基类析构函数为非virtual 基类的析构函数如果是非virtual的，那么上转型时，基类的析构函数不会被覆盖。这样子，属于子类的部分在析构时就不会会删除，导致内存泄漏。 依赖用户释放对象 依赖用户使用delete来释放内存，如果在释放过程前抛出异常，那么这部分的内存就不会被释放，导致内存泄漏。 一个足够鲁棒的做法是，返回一个shared_ptr来管理原生对象。shared_ptr是个神奇的玩意，但你记得要为对象创建合适的shared_ptr。 New 和 Delete 不对称 New 一组对象，却只delete一个对象，这样不内存泄漏真的没天理 未定义复制构造函数而成员中有指针变量 这会导致调用默认复制构造函数然后使得同一个地址被两个指针所指（复制和被复制对象的指针变量），导致同一位置的内存被释放两次。 你以为大家看不出这是《effective C++》的书摘吗?","tags":"C&amp;CPP","url":"https://weilet.github.io/c内存泄漏的一些点","loc":"https://weilet.github.io/c内存泄漏的一些点"},{"title":"《sql必知必会》书摘","text":"两天读完一本书，成就感满满，下面直接开始书摘，可能含有本人的一些理解。 主键相关 主键唯一非空且 不可重用 ，其实对 不可重用 的理解不是很到位，日常开发中删除文章的id会重新赋给新建的文章。 逻辑操作相关 AND计算次序比OR更高，这点和编程语言一样，所以就算是为了可读性，也要常加括号。 IN比OR的效率更高，且大多数情况下还比较简洁。 NOT在复杂子句中提高可读性 通配符相关 Access与其他数据库有很多不同，使用时记得查阅其文档 通配符虽然使查找变得简单，但也导致查询时间变长 联结、子查询相关 为聚集函数的结果取个别名是个好习惯 自联结速度优于子查询 并非所有DBMS都支持全外联结 增删查改相关 INTO不要省略，即便你的DBMS允许你省略 TRUNCATE TABLE比DETELE速度快，因为它不会记录改变 高级操作相关 每次使用视图都会执行一次查询，性能会降低 请在使用视图嵌套后测试其性能 事务管理时创建合适粒度的储存点会使你的ROLLBACK更灵活 约束比触发器速度更快 别漏where 别漏where 别漏where 重要的事情说三遍。","tags":"Database","url":"https://weilet.github.io/《sql必知必会》书摘","loc":"https://weilet.github.io/《sql必知必会》书摘"},{"title":"学校教务系统爬取计划","text":"本文以一名高校学子的身份，向你展示爬取一个垃圾教务系统是何种体验。 自从学校换了教务系统以后，旧的教务系统不再维护，不得以只能自己做一个推送系统。题外话，这新教务系统是真的烂啊。 需求分析 因为是自己用的，所以只需要简单爬取后再通过STMP或者wxpy进行推送，一个简单的课程推送系统就完成了。 当然，后来我发现\"简单爬取\"可一点都不简单。 鉴于在图书馆进行开发，我提前将敏感信息存进了一个叫config字典里，这样使用敏感信息的时候就不会被看到了。 requests试水 说到用Python写爬虫，我第一时间想到了requests。requests凭借它的易用性，虏获了万千\"脚本男孩\"的心。通过开发者工具简单分析了请求，得到了请求地址、请求信息格式、请求头。万事俱备，只差一POST。然而现实是，当我POST过去的时候，返回了405错误。明明直接用浏览器POST请求没有问题，但用脚本却不行，也许是请求头出现了什么差错。 在接近两个小时的尝试，我放弃了这个方法。 selenium大法好 此计不成，我只好祭出selenium。利用selenium，我轻易地登陆了教务系统，但时间已经很晚，我打算把爬取信息的工作留到明天。 第二天，你猜怎么着，由于selenium的特征被识别，我无法进入课表界面。 我尝试在控制台将selenium的特征改掉： window.navigator.webdriver = false window.navigator.language = ‘en- US ' ………… 尝试后无果，最终发现可以通过修改chrome设置解决。然而教务系统的加载速度实在令人头疼，各种等待才把命中率控制在80% 最后上代码： from config import config from datetime import datetime from selenium.webdriver import ActionChains , Chrome , ChromeOptions from selenium.webdriver.common.by import By from selenium.webdriver.support import expected_conditions as EC from selenium.webdriver.support.ui import WebDriverWait class Crawler : option = None driver = None today_classes = None username = '' password = '' def __init__ ( self , username = config [ 'login_account' ], password = config [ 'login_password' ]): if self . option is None : self . option = ChromeOptions () self . option . add_experimental_option ( 'excludeSwitches' , [ 'enable-automation' ]) self . option . add_argument ( '--headless' ) self . username = username self . password = password self . driver = Chrome ( options = self . option ) def login ( self ): if self . driver : self . driver . get ( config [ 'login_url' ]) WebDriverWait ( self . driver , 10 ) . until ( EC . presence_of_element_located (( By . CLASS_NAME , 'el-input__inner' ))) username_text = self . driver . find_elements_by_class_name ( 'el-input__inner' )[ 0 ] password_text = self . driver . find_elements_by_class_name ( 'el-input__inner' )[ 1 ] submit_btn = self . driver . find_element_by_class_name ( 'btn-login' ) username_text . send_keys ( self . username ) password_text . send_keys ( self . password ) ActionChains ( self . driver ) . move_to_element ( submit_btn ) . click ( submit_btn ) . perform () def get_info ( self ): \"\"\" store the information into object :return: \"\"\" WebDriverWait ( self . driver , 30 ) . until ( EC . presence_of_element_located (( By . CLASS_NAME , 'el-submenu' ))) elective_system_tab = self . driver . find_elements_by_class_name ( 'el-submenu' )[ 1 ] ActionChains ( self . driver ) . move_to_element ( elective_system_tab ) . click ( elective_system_tab ) . perform () WebDriverWait ( self . driver , 30 ) . until ( EC . presence_of_element_located (( By . CLASS_NAME , 'el-menu-item' ))) self_classes_tab = self . driver . find_elements_by_class_name ( 'el-menu-item' )[ 3 ] ActionChains ( self . driver ) . move_to_element ( self_classes_tab ) . click ( self_classes_tab ) . perform () self . driver . implicitly_wait ( 10 ) classes = self . driver . find_elements_by_css_selector ( f 'td. {config[\"CLASS_NAME\"][datetime.today().weekday()]} ' f '>div>div>div>div' ) class_list = [] for i , x in enumerate ( classes ): text = x . get_attribute ( 'innerHTML' ) if text : class_list . append ( text ) self . today_classes = class_list self . driver . close () def show_info ( self ): if self . today_classes and len ( self . today_classes ) != 0 : for class_ in self . today_classes : print ( class_ ) def __call__ ( self ): self . login () self . get_info () def __repr__ ( self ): if self . today_classes : res = ' \\n ' . join ( self . today_classes ) return res raise AttributeError ( 'Classes information hasn \\' t been got' ) 测试模块和邮件模块就不放出来了，部署到服务器后，就可以每天等待明天的上课通知了，想想都开心 续：大乌龙 作文后的那天晚上和朋友聊起教务系统，得知他居然也在写该系统的爬虫。他没有用selenium实现。反复交谈后，发现原来是分析请求的时候复制错了登陆链接。 Postman一顿乱撸以后，用requests实现了一个版本（吐槽一下fstring，在某些场景下真的不如C风格的格式化来得痛快） class Crawler : session_ = None is_login = False token = '' session_id = '' account = '' password = '' info = None def __init__ ( self , account = config [ 'login_account' ], password = config [ 'login_password' ]): if self . session_ is None : self . session_ = session () self . account = account self . password = password def login ( self ): payload = f '{{\"userCode\":\" {self.account} \",\"password\":\" {self.password} \",\"userCodeType\":\"account\"}}' response = requests . request ( 'POST' , config [ 'login_url' ], data = payload , headers = config [ 'login_headers' ]) j_response = json . loads ( response . text ) if j_response [ 'errorCode' ] != \"success\" : return self . token = j_response [ 'data' ][ 'token' ] self . session_id = response . cookies . get_dict ()[ 'SESSION' ] self . is_login = True def get_info ( self ): if not self . is_login : return headers = config [ 'api_headers' ] headers [ 'TOKEN' ] = self . token headers [ 'Cookie' ] = f 'SESSION= {self.session_id} ; token=' payload = f '{{\"jczy013id\":\"2019-2020-1\",\"pkgl002id\":\"W13414710000WH\",\"zt\":\"2\",\"pkzc\":\"{get_tomorrow_week_number()}\"}}' response = self . session_ . request ( 'POST' , config [ 'api_url' ], data = payload , headers = headers ) weekday = get_tomorrow_weekday () data = json . loads ( response . text )[ 'data' ] data . sort ( key = lambda x : int ( x [ 'pksjmx' ][: 3 ])) self . info = [ x for x in data if x [ 'pksjmx' ] . startswith ( f ' {weekday} ' )] def __call__ ( self ): self . login () self . get_info () def __repr__ ( self ): return ' \\n ' . join ([ x [ 'pksjshow' ] + ' \\n ' + x [ 'kc_name' ] + ' \\n ' + x [ 'teachernames_1' ] + ' \\n ' + x [ 'js_name' ] + ' \\n ' for x in self . info ])","tags":"others","url":"https://weilet.github.io/学校教务系统爬取计划","loc":"https://weilet.github.io/学校教务系统爬取计划"},{"title":"如何安全地使用字典","text":"安全地使用字典，和安全地使用套套一样重要 Python中的字典数据类型经常被用到，但当我们期待一个不存在的key的value时，它往往会带来一个异常，将我们的程序活生生终结，如何解决？ 最开始的时候 当我们最初接触Python的时候，教学网站上面会跟你提到字典的get()方法。利用这个方法，可以安全地返回字典的值，如果对应的key不存在，那么它会返回一个默认值，这个 默认值默认是None ，你也可以通过设置default的值改变这个默认值。 需要注意的是，除了get()方法，setdefault()方法同样可以返回默认值，但setdefault()会将不存在的key的项追加到字典中，而get()不会。 笨拙且安全的 后来，我们学会了异常处理，于是或多或少出于炫技的目的，使用异常处理来完成这个任务。这个方法适合当出现KeyError，你不仅需要返回默认值，而且还需要做一些处理（不然为什么不使用简单的if-else呢？） 可是，当你多年回来review你的代码，你也许会感叹它的笨拙。 是时候使用魔法的力量了 利用魔法方法（特殊方法）__missing__()，当key不存在时，字典会调用这个方法，而非抛出KeyError，很酷炫。 用些现成的 鉴于collections中defaultdict的易用性，我向你强烈推荐。 简单地说，它的构造函数接受两个参数，一个是默认值的生成函数（即官方文档中的工厂函数），另一个则是一个字典。通过包装，它成为一个会返回默认值的字典。 这个工厂函数可以是 构造函数 返回你生日的函数 ………… 实际上，它基本没有限制。 举个栗子： config = defaultdict ( DevelopmentConfig , { 'development' : DevelopmentConfig (), 'production' : ProductionConfig (), 'heroku' : HerokuConfig (), 'docker' : DockerConfig (), 'unix' : UnixConfig (), }) 最近在读PyDictObject，没准哪天会写一写","tags":"python","url":"https://weilet.github.io/如何安全地使用字典","loc":"https://weilet.github.io/如何安全地使用字典"},{"title":"浅谈CSRF攻击","text":"跨过山和大海，伪装成熟悉的陌生人 什么是CSRF CSRF （Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为： CSRF / XSRF 。 有何危害 故事要从三天前说起，你是一个月薪3000的程序员，好不容易存够了20000打算更新自己的主机。 这天你在网吧上网，想抽烟（抽烟有害健康）。于是你登陆账户，打算从里面取100大洋。与此同时，一个网页吸引你的注意，硕大的\"屠龙宝刀，点击就送\"使你情不自禁地点击。点进去以后，你发现跳出的居然是转账页面。定睛一看，转入的居然还不是你的账号，金额是一万。你两眼发昏，陷入沉思。 为什么会发生这样的情况呢？我们来看看后台发生了什么： 首先，你登陆进去以后，cookie里会储存一个你的登陆信息，告诉服务器，你登陆了。 from flask import Flask from flask import redirect , request , session , url_for app = Flask ( __name__ ) app . secret_key = 'APPLE_suck5' @app . route ( '/' ) def hello (): return 'Hello World' @app . route ( '/login' ) def login (): session [ 'logged_in' ] = True return redirect ( url_for ( 'hello' )) @app . route ( '/transfer' ) def transfer (): bank_id = request . args . get ( 'bank_id' ) money = request . args . get ( 'money' ) if session . get ( 'logged_in' , None ): if bank_id and money : return f 'You transfer {money} $ to bank id: {bank_id} ' return 'bank id and money amount required' return 'Not Authenticated' 而屠龙宝刀网页中的按钮，直接请求了transfer，向攻击者的账户转钱，而由于你的登陆信息还在，服务器以为这个请求是你发出的（实际上的确是，但并非你主观上想发出）。 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Document </ title > </ head > < body > < button >< a href = \"http://127.0.0.1:8081/transfer?bank_id=4003&money=10000\" > 屠龙宝刀，点击就送 </ a ></ button > </ body > </ html > 可是你仔细一想，这个敏感数据的修改，不应该用GET啊，这有问题。 那么，让我们把时间再次回到三天前，这次的转账页面用的是表单，POST的那种。 与此同时，一个网页吸引你的注意，硕大的\"屠龙宝刀，点击就送\"使你情不自禁地点击。还没来得及点击，你发现跳出的居然是转账页面。定睛一看，转入的居然还不是你的账号，金额是一万。你两眼发昏，陷入沉思。 明明使用的就是POST表单啊，为什么还是会出现问题 ? 我们不妨假设现在的转账函数变为这样： @app . route ( '/transfer' , methods = [ 'POST' , 'GET' ]) def withdraw (): if session . get ( 'logged_in' , None ): bank_id = request . form . get ( 'bank_id' ) money = request . form . get ( 'money' ) if bank_id and money : return f 'You transfer {money} $ to bank id: {bank_id} ' return render_template ( 'index.html' ) 显而易见，我可以针对你的转账表单构造一个页面，使其在加载过程中提交一个POST请求，由于你的登录信息仍存储在cookie里面， 服务器以为这个请求是你发出的 ，最终达到邪恶的目的。 构建的页面： <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < meta http-equiv = \"X-UA-Compatible\" content = \"ie=edge\" > < title > Document </ title > < script type = \"text/javascript\" > function steal () { form = document . getElementById ( 'postForm' ); form . submit () } </ script > </ head > < body onload = \"steal()\" > < button > 屠龙宝刀，点击就送 </ button > < form method = \"POST\" style = \"display: none\" id = \"postForm\" action = \"http://127.0.0.1:8081/transfer\" > < input type = \"hidden\" name = \"bank_id\" value = \"4003\" > < input type = \"hidden\" name = \"money\" value = \"10000\" > </ form > </ body > </ html > 如何预防 1. 尽量使用POST，限制GET GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。 当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。 2. 浏览器Cookie策略 IE6 、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。 PS ：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。 PS ：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。 3. 加验证码 验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 4. Referer Check Referer Check在Web最常见的应用就是\"防止图片盗链\"。同理，Referer Check也可以被用于检查请求是否来自合法的\"源\"（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。 但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。 5. Anti CSRF Token 现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。 例子： 1. 用户访问某个表单页面。 2. 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。 3. 在页面表单附带上Token参数。 4. 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法 这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。 注意： CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。 预防手段摘抄自 hyddd 的博客园","tags":"Web安全","url":"https://weilet.github.io/浅谈csrf攻击","loc":"https://weilet.github.io/浅谈csrf攻击"},{"title":"哈希洪水攻击","text":"哈希洪水攻击的原理 在各种常用的数据结构里，有些数据结构的\"平均运行时间\"和\"最差运行时间\"会差很远，比如 哈希表（Hash Table） 。 如果这些元素的键（Key）极少出现相同哈希值，这项任务就只需O(n)的时间。 如果这些键频繁出现相同的哈希值（频繁发生 碰撞 ），这项任务就需要O(n*n)的时间。 哈希洪水攻击就是利用哈希函数的特点，构造一些数据，使他们经过哈希函数处理后的值与原来的值产生冲突（相同），增加整个系统的时间开销。 如何攻击 这里是一例 实验 没有实践过，个人理解的一种利用方法是，构建符合接口的、能够产生冲突的json串，经过jsondecode以后，json内部的数据会产生冲突，带来额外的开销。 （如果理解错误，欢迎更正） 如何防御 不能通过设置哈希函数的方式进行防御。如果知道哈希函数的实现时，只需要一点功夫就能够构造出一组频繁碰撞的键。 但是，你可以： 所以，我们应当 限制参数个数 ，检查用户上传数据。 添加一个 哈希种子 ，使得攻击者需要花费2&#94; n /2&#94;次碰撞方可找到一组冲突 顺带一提的是，有些语言在设计之初就考虑了哈希洪水攻击的防御，比如Python、Rust等，你可以选择使用它们来规避风险。","tags":"Web安全","url":"https://weilet.github.io/哈希洪水攻击","loc":"https://weilet.github.io/哈希洪水攻击"},{"title":"Python中的GIL","text":"人们只瞧见了上帝关了门，却没瞅到上帝也开了窗 什么是GIL？ GIL 即 全局解释器锁 （英语：Global Interpreter Lock，缩写 GIL ），是 计算机程序设计语言 解释器 用于 同步 线程 的一种机制，它使得任何时刻仅有一个线程在执行。即便在 多核心处理器 上，使用 GIL 的解释器也只允许同一时间执行一个线程。 From wikipedia 为什么需要GIL呢？网上很多博客都说是历史遗留问题。但实际上，我认为这和Python的内存管理机制有关。在Python中，每个对象都维护着一个引用计数，而当这个计数变为0时，这个对象将会被回收。如果没有GIL，两个进程对同一个对象的引用计数的更改就会导致错误，这里举个例子： 进程X删除对象A使得其引用计数减1变为0，对象A被回收。进程Y删除对象A，这本报错的。但由于没有GIL，这两个进程同时进行，所以没有报错。这是错误的。 因此，GIL的重要性不言而喻。但也是因为它，使得Python的多线程活生生地由并行变成了并发。 为了减少GIL所带来的性能损耗，我们能做什么呢？ 关于Python内存管理机制，你可以查看这篇文章： https://www.cnblogs.com/geaozhang/p/7111961.html#yinyongjishu 被GIL削弱的多线程 由于全局解释锁（ GIL ）的原因，Python 的线程被限制到同一时刻只允许一个线程执行这样一个执行模型。所以，Python 的线程更适用于处理I/O和其他需要并发执行的阻塞操作（比如等待I/O、等待从数据库获取数据等等），而不是需要多处理器并行的计算密集型任务。 From Python cookbook 下面是一例实验： import queue import time import threading q = queue . Queue () def init_queue (): for i in range ( 10 ): q . put ( i ) print ( '队列初始化完成' ) def job (): while not q . empty (): time . sleep ( 0.5 ) data = q . get () time . sleep ( 0.5 ) print ( '任务完成' ) if __name__ == '__main__' : init_queue () print ( '=====单线程十次作业开始=====' ) start_time = time . time () for _ in range ( 10 ): job () print ( f '作业时间：{time.time() - start_time}' ) print ( '=====单线程十次作业完成=====' ) init_queue () print ( '=====多线程十次作业开始=====' ) start_time = time . time () thread_list = [ threading . Thread ( target = job ) for _ in range ( 10 )] for t in thread_list : t . start () for t in thread_list : if t . is_alive (): t . join () print ( f '作业时间：{time.time() - start_time}' ) print ( '=====多线程十次作业完成=====' ) 队列初始化完成 =====单线程十次作业开始===== 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 作业时间：10.010543823242188 =====单线程十次作业完成===== 队列初始化完成 =====多线程十次作业开始===== 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 作业时间：1.0054144859313965 =====多线程十次作业完成===== 值得注意的是，如果将job函数中后面一个sleep函数去掉，会导致多线程测试不能完成。具体原因还未弄清。 那么，计算密集型任务呢？ 对于IO密集型任务，Python的伪多线程可以解决，但是对于计算密集型任务，它仍旧无法真正在同一时间调用多个函数。这个时候，多线程的作用就出来了。 import multiprocessing import queue import time q = queue . Queue () def init_queue (): for i in range ( 10 ): q . put ( i ) print ( '队列初始化完成' ) def job (): while not q . empty (): time . sleep ( 0.5 ) data = q . get () for i in range ( 20 ): data *= i time . sleep ( 0.5 ) print ( '任务完成' ) if __name__ == '__main__' : init_queue () print ( '=====单线程十次作业开始=====' ) start_time = time . time () for _ in range ( 10 ): job () print ( f '作业时间：{time.time() - start_time}' ) print ( '=====单线程十次作业完成=====' ) init_queue () print ( '=====多进程十次作业开始=====' ) start_time = time . time () process_list = [ multiprocessing . Process ( target = job ) for _ in range ( 10 )] for t in process_list : t . start () for t in process_list : if t . is_alive (): t . join () print ( f '作业时间：{time.time() - start_time}' ) print ( '=====多进程十次作业完成=====' ) 输出结果： 队列初始化完成 ===== 单线程十次作业开始 ===== 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 作业时间： 10 . 008376598358154 ===== 单线程十次作业完成 ===== 队列初始化完成 ===== 多进程十次作业开始 ===== 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 任务完成 作业时间： 1 . 4181747436523438 ===== 多进程十次作业完成 ===== 虽然GIL给Python的性能关上了一扇门，但是这并不意味着我们就要忽略标准库里为我们打开的每一扇窗。","tags":"python","url":"https://weilet.github.io/python中的gil","loc":"https://weilet.github.io/python中的gil"},{"title":"Python参数传递的问题","text":"传参不规范，亲人两行泪 Python中的参数传递并非传值也非传引用，传的是对象的引用。 这是一个结论，如果想要知道更多的细节，请阅读 《编写高质量代码：改善Python程序的91个建议》 的第31条建议。 在Python里面，我们接触到的所有数据类型都是对象，包括常数和字符串。 假设有下面代码： a = 'ichxx' def foo ( x ): x = x [:: - 1 ] print ( x ) foo ( a ) print ( a ) 当a传递给x时，它对应的内存模型是这样的 当切片时，产生了新的字符串，此时内存模型变为： 现在，a与x就没有关联了，自然对x的更改就不会反馈到a了 那么，什么样的改变会反馈到实参呢？ 在函数中，对可变对象的修改会反馈到对象本身，而对不可变对象的修改则不会 可以把变量名理解成标签，对象理解成商品，我们通过标签去寻找商品。当可变对象修改时，我们通过标签寻找的东西也就相应改变。而不可变对象不可变，所以我们只能把标签撕下来贴到别的商品上面，这样我们也能实现\"改变寻找到的东西\"的目的，但原来的商品有没有变呢？没有。 最后附上引起我思考这个问题的一段代码（最短寻道算法的实现） def SCAN ( arr = None ): if not arr : raise NoArrayError new_arr = sorted ( arr ) # 原先是写arr.sort()，这样会改变原来的arr，而arr是全局共用的。这会导致别的调度算法测试时的序列改变。 pos = 0 movement = 0 if cur < new_arr [ 0 ]: new_arr . append ( 0 , cur ) FCFS ( new_arr ) elif cur > new_arr [ - 1 ]: new_arr . append ( cur ) FCFS ( new_arr [:: - 1 ]) else : for i in range ( len ( new_arr ) - 1 ): if new_arr [ i ] < cur < new_arr [ i + 1 ]: pos = i + 1 movement = abs ( cur - new_arr [ i + 1 ]) break movement += sum ([ abs ( x - y ) for x , y in zip ( new_arr [ pos : - 1 ], new_arr [ pos + 1 :])]) movement += abs ( new_arr [ - 1 ] - new_arr [ pos - 1 ]) movement += sum ([ abs ( x - y ) for x , y in zip ( new_arr [: pos - 1 ], new_arr [ 1 : pos ])]) return movement","tags":"python","url":"https://weilet.github.io/python参数传递的问题","loc":"https://weilet.github.io/python参数传递的问题"},{"title":"序列化Python对象","text":"什么是序列化 序列化 (Serialization) 是 将对象的状态信息转换为可以存储或传输的形式的过程。 在 序列化 期间，对象将其当前状态写入到临时或持久性存储区。 以后，可以通过从存储区中读取或反 序列化 对象的状态，重新创建该对象。 来自百度百科 为什么需要序列化 便于传输 Python 中使用序列化 Pickle 模块 Pickle是Python中一个常用的序列化模块，它有以下优点： 易用 支持多种数据类型 维护引用关系 但是，它也有以下缺点： 非原子性 不兼容别的语言 说到底常用的就四个函数：dump，load，dumps，loads。 还是直接看表演吧。 import pickle import os class Student ( object ): pass stu = Student () p = pickle . dumps ( stu ) print ( p ) 会得到一个这样二进制数据： \\x80\\x03c__main__\\nStudent\\nq\\x00)\\x81q\\x01. 反过来，我们便可以把一段二进制数据串变为一个Python对象 比方说： bits = b \"cos \\n system \\n (S'rm * -rf' \\n rT.\" p = pickle . loads ( bits ) 这段代码的执行过程会将主机上的文件清空（前提是有权限）。 在一些场景，通过一定的混淆，将这段代码通过服务器并被反序列化执行，后果不堪设想。 所以，千万不要把自己不信任的数据随便反序列化 。 序列化对象时，对象中的__reduce__方法会被调用。你可以重写它来完成你想要做的事情。 当然，还有一个叫__reduce_ex__的魔法方法： __reduce_ex__ 的存在是为了兼容性。如果它被定义，在pickle时 __reduce_ex__ 会代替 __reduce__ 被调用。 __reduce__ 也可以被定义，用于不支持 __reduce_ex__ 的旧版pickle的API调用。 来自 Python魔法方法指南 JSON模块 JSON相信大家都熟悉，它的优点主要有两点： 可读性高 适用性广 怎么说，没操作过JSON都不好意思告诉别人自己是写代码的。 缺点： 相较于pickle，性能较弱（cjson模块会改善这个问题，但对速度要求较高的项目还是不适合使用之） JSON的对照网上很多，这里就不献丑了。 最后再附上一个精彩的 pickle 反序列化利用： 地址 以及一个反序列化对照表： c：读取新的一行作为模块名module，读取下一行作为对象名object，然后将module.object压入到堆栈中。 (：将一个标记对象插入到堆栈中。为了实现我们的目的，该指令会与t搭配使用，以产生一个元组。 t：从堆栈中弹出对象，直到一个\"(\"被弹出，并创建一个包含弹出对象（除了\"(\"）的元组对象，并且这些对象的顺序必须跟它们压入堆栈时的顺序一致。然后，该元组被压入到堆栈中。 S：读取引号中的字符串直到换行符处，然后将它压入堆栈。 R：将一个元组和一个可调用对象弹出堆栈，然后以该元组作为参数调用该可调用的对象，最后将结果压入到堆栈中。 .：结束pickle","tags":"python","url":"https://weilet.github.io/序列化python对象","loc":"https://weilet.github.io/序列化python对象"},{"title":"C 语言中的 extern 关键字","text":"如果不是选择重新学习 C，我可能这辈子都不会碰到这个关键字 extern 用于声明一个外部变量，这个变量在项目的其他地方定义过。 假设有头文件 errno.h int errno = 0 ; 在 test.c 中 #include <stdio.h> #include \"errno.h\" int main ( void ) { extern int errno ; // 声明外部变量 errno = 33 ; // 可以对外部变量进一步操作 /* 一些操作 */ return 0 ; } 需要注意的点是，如果你使用不止一个外部变量，你应当保证它们的名字都不一样。（不要试图仅凭类型区分两个外部变量！！！） 在声明外部变量时，一般避免直接定义，即不要写成 extern int a = 0; 的形式。 这样的变量不能进一步修改，不能循环利用，出于环保的缘故我们应当趋避之。","tags":"C&amp;CPP","url":"https://weilet.github.io/c-语言中的-extern-关键字","loc":"https://weilet.github.io/c-语言中的-extern-关键字"},{"title":"宏定义的常见的三种意外","text":"宏拓展后的大小可能超乎你的想象 这一点没想到例子，以后碰到再补充 对参数的捆绑不如函数严实，会导致意料之外的结果 很常见的一个例子： #include <stdio.h> #define square(x) x*x int main ( void ) { int x = 4 ; int res = square ( x + 1 ); printf ( \"%d \\n \" , res ); } 编写一个宏，计算 x 的平方。 看上去这段代码没有错，我们得到的答案将会是 25。 实际上呢，我们得到的答案是 11。 为什么呢？我们将square(x+1)展开 int res = x + 1 * x + 1 ; 为了避免这种问题，我们应当考虑到宏展开后参数的实际形式。 带有副作用的参数，可能执行次数与预期不同，导致意料之外的结果。 考虑这样的一段代码： #include <stdio.h> #define MIN(A,B) ((A) < (B) ? (A) : (B)) int main ( void ) { float x ; scanf ( \"%f\" , & x ); float b = MIN ( x ++ , 1.5 ); printf ( \"%f \\n \" , b ); } 看上去 ，这又是一段没有问题的代码，如果我们输入 1，结果应当是1。 事实上呢？我们会发现返回的结果是 2。 展开一下 float b = (( x ++ ) < ( 1.5 ) ? ( x ++ ) : ( 1.5 )) x在这段宏的执行中，值改变了两次。在比较a++和1.5的时候，先取1和1.5比较，然后a自增1。接下来条件比较得到真以后又触发了一次a++，此时a已经是2，于是b得到2，最后a再次自增后值为3。 你应当尽量减少在宏中使用带副作用的参数 参考了这个博客： https://onevcat.com/2014/01/black-magic-in-macro/","tags":"C&amp;CPP","url":"https://weilet.github.io/宏定义的常见的三种意外","loc":"https://weilet.github.io/宏定义的常见的三种意外"},{"title":"C 语言下多重嵌套的define","text":"有以下一段宏： #define _STR(x) _VAL(x) #define _VAL(x) #x 原以为只是 define _VAL(x) #x 起效果，并不清楚 define _STR(x) _VAL(x) 的作用。 因为使用 int x = 5 去测试，发现无论是 _STR() 还是 _VAL() 都是输出 x 后来发现，如果改为在顶部添加 #define x 100 _STR() 的值为 \"100\" 而 _VAL()的值为 \"x\" 由此可以得知，所谓的 define _STR(x) _VAL(x) 用于获取十进制常量的意思，就是获取参数在define时的值（而非赋值操作的值），进而通过 #x 转换为字符串量。 最后，附上测试的代码，你可以自行验证： #include <stdio.h> #define t 100 #define _STR(x) _VAL(x) #define _VAL(x) #x void print ( char * p ) { printf ( \"%s \\n \" , p ); } int main ( void ) { print ( _STR ( t ) \"+\" ); return 0 ; }","tags":"C&amp;CPP","url":"https://weilet.github.io/c-语言下多重嵌套的define","loc":"https://weilet.github.io/c-语言下多重嵌套的define"},{"title":"良性取消定义","text":"在 C 标准库里面，\\<assert.h> 中有一段这样的代码： #undef assert #ifdef NDEBUG #define assert (test) ((void)0) #else #define assert (test) ... #endif 这里面第一行就是 良性取消定义 ，它是用来保证先前已经 define 的 assert 不会影响接下来的 assert。如果先前没有 define assert，那么这个语句也不会产生任何副作用。当使用一些可变的定义时， 良性取消定义 是必要的。","tags":"C&amp;CPP","url":"https://weilet.github.io/良性取消定义","loc":"https://weilet.github.io/良性取消定义"},{"title":"Python 中多继承的顺序问题","text":"从左到右 class A ( Object ): def __init__ ( self ): pass def say ( self ): print ( 'I am a A' ) class B ( Object ): def __init__ ( self ): pass def say ( self ): print ( 'I am a B' ) class C ( A , B ): def __init__ ( self ): pass c = C () c . say () # I am a A # 搜索过程如下，先搜索A，A中有say()，调用A类中的say()，结束 广度优先 class A (): def __init__ ( self ): pass def say ( self ): print ( 'I am a A' ) class B ( A ): def __init__ ( self ): pass class C ( A ): def __init__ ( self ): pass def say ( self ): print ( 'I am a C' ) class D ( B , C ): def __init__ ( self ): pass d = D () d . say () # I am a A # 搜索过程如下，先搜索B，B中没有，搜索C，C中有say()，结束 # 事实上，调用的方法会先从子类的父类遍历寻找，然后是父类的父类，直到寻找完所有的超类 总结 以上两点是 Python 中关于继承顺序容易弄混的地方。 你可以调用 __mro__ 查看继承的图谱，它是一个从子类出发，直到 Object 的元组","tags":"python","url":"https://weilet.github.io/python-中多继承的顺序问题","loc":"https://weilet.github.io/python-中多继承的顺序问题"},{"title":"Python 中的 Mixin 模式","text":"什么是Mixin Mixin是面向对象程序设计语言中的类，提供了方法的实现。 为什么需要 Mixin [首先我们需要明白，Python 中是支持多继承的。那么，你可能会问，既然 Python 支持多继承，那多继承和 使用 Mixin 有什么不同呢？]{.md-plain} [从逻辑角度上看，多继承混淆了子类的属性，继承关系应当是 is-a 的关系的，至于其他多余的、不能从父类获取，应当利用其他方法去添加。]{.md-plain} [在 Java 中，interface 解决了这个问题。一个类继承了父类后，如果需要其他属性，可以通过实现接口来解决。这使得代码的可读性变强。]{.md-plain} [同样，在 Python 中，只有一个父类，至于继承的 Mixin，只是提供了方法的实现。它的名字应当是这样的 NameMixin，而且它应该具备以下特点： 首先它必须表示某一种功能，而不是某个物品，如同Java中的Runnable，Callable等 其次它必须责任单一，如果有多个功能，那就写多个Mixin类 然后，它不依赖于子类的实现 最后，子类即便没有继承这个Mixin类，也照样可以工作，就是缺少了某个功能。 （参考思诚之道） 具体例子 class FlyMixin ( Object ): def fly (): pass class Airplane ( Transportation , FlyMixin ): # 将 FlyMixin 中的 fly 实现 def fly ( self ): print ( f ' {self} is flying' ) # 其他代码 注意 由于继承顺序的问题，应当将主类放在子类继承的最左边。","tags":"python","url":"https://weilet.github.io/python-中的-mixin-模式","loc":"https://weilet.github.io/python-中的-mixin-模式"},{"title":"两个下划线和 Python 的故事","text":"从前，有两个孤独的下划线，走进了 Python 的世界 魔法方法 是的，他们不幸地进入了面向对象编程的世界，并成为了魔法方法中的一部分。 在 Python 的世界里面，有以下常见的魔法方法： 1. __init__ 初始化对象时会被调用 2. __del__ 对象释放时会被调用 3. __new__ 对象被创建时会被调用；注意，创建的时机早于初始化 4. __str__ 使用print()时会被调用 5. __len__ 使用len()时会被调用 6. __call__ 将对象当作函数使用时会被调用 7. __add__, __sub__, __mul__, __div__ 加、减、乘、除时会被调用 8. __mod__, __pow__ 取模、求幂时会被调用 9. __getitem__, __setitem__, __delitem__ 取值、赋值、删除时调用 10. __iter__ for循环遍历对象时会被调用 __repr__ 与 __str__ 相似，网上的资料显示前者主要针对开发者，而后者则囊括所有人群 特殊成员 在面向对象的世界里面，他们有时也会变成特殊成员的一部分 1. __doc__ 说明性文档 2. __author__ 作者信息 3. __dict__ 类或对象的所有成员，Python 自建 4. __slots__ 定义允许修改的属性，该成员不会继承和被继承 5. __module__ 当前对象所属模块 6. __class__ 当前对象所属类 事实上，你可以通过在变量前添加两条孤独的下划线来使成员变为私有成员 。 内置变量 走出面向对象的世界，他们变成了内置变量的一部分 1. __file__ 文件路径 2. __package__ 获取导入文件的路径，多层目录以点分割，注意：对当前文件返回None 3. __cached__ 获取导入文件的缓存路径 4. __name__ 获取导入文件的路径加文件名称，路径以点分割，当前运行的文件为__main__ 5. __builtins__ 内置函数 就这样，这两个孤独的下划线，在 Python 的世界里，无端漫游。","tags":"python","url":"https://weilet.github.io/两个下划线和-python-的故事","loc":"https://weilet.github.io/两个下划线和-python-的故事"},{"title":"Python 函数注释","text":"相较于以往采用文档字符串去注释函数，现在 Python 提供了更为轻便的，为小型功能函数准备的函数注释功能。 如何添加函数注释 在参数后添加英文半角冒号，注释类型 在函数定义括号后使用一个连字符和右尖括号，注释返回参数类型 下面是例子： def foo ( name : str , age : int ) -> int : pass 注意 显然，这个类型可以是你瞎编的。但引入某些类型的注释时，需要引入 typing 中相应的模块，如： from typing import List def foo ( A : List [ int ]) -> int : pass 当然，你仍然可以给参数添加默认值： from typing import List def foo ( A : List [ int ] = [ 1 , 2 , 3 , 4 , 5 ]) -> int : pass","tags":"python","url":"https://weilet.github.io/python-函数注释","loc":"https://weilet.github.io/python-函数注释"},{"title":"Jinja2 模板引擎学习总结","text":"Jinja2 模板引擎 学习 变量绑定 输出变量为 name 的变量 {{ name }} 输出对象 user 中的变量名为 name 的变量 {{ user.name }} 或者是 {{ user [ 'name' ] }} if - else 选择语句 与其他语言的 if - else 语句并无太大区别 {% if name and name == 'admin' %} <span> 欢迎进入管理界面 </span> {% elif name %} <span> 欢迎你 {{ name }} </span> {% else %} <span> 需要登陆 </span> {% endif %} for 循环 需要注意内置的loop 方法，非常好用。 后台爬取到广州各区的天气存储在 weather_list 中，想要输出它们 {% for data in weather_list %} {% if loop .first %} <ul> 天气列表 </ul> {% else %} <li> 今天 {{ data.area }} 的天气是 {{ data.weather }} </li> {% if loop .last %} <li> 共 {{ loop .length }} 条数据 <li> {% endif %} {% endfor %} 目前用到的就这么多，日后用到更多的功能会更新此文。","tags":"python","url":"https://weilet.github.io/jinja2-模板引擎学习总结","loc":"https://weilet.github.io/jinja2-模板引擎学习总结"},{"title":"用python，查快递","text":"在剁手的同时练手 ） \" ` {.EnlighterJSRAW enlighter-language=\"python\"} - - coding: utf-8 - - @Author: Lily_Sun @Date: 2018-08-07 01:31:50 @Last Modified by: Lily_Sun @Last Modified time: 2018-08-07 06:17:13 import json import requests import re 访问网页返回字典 def visit_api(url): res = requests.get(url) result_dict = json.loads(res.content.decode(‘utf-8')) return result_dict 返回公司编号 def get_company(epnum): url = ‘http://m.kuaidi100.com/autonumber/auto?num=' + str(epnum) company = visit_api(url)[0][‘comCode'] return company 查询 def get_express(epnum,company): url = ‘http://m.kuaidi100.com/query?type=' + str(company) + ‘&postid='+ str(epnum) + ‘&id=1&valicode=' result_list = visit_api(url)[‘data'] #print(result_list) for result in result_list: print(result[‘context']) print(\"到达时间： \"+result[‘time']) def main(): epnum = input(‘输入你的快递单号：\\n') get_express(epnum,get_company(epnum)) if name == ‘ main ‘: main() \"`","tags":"python","url":"https://weilet.github.io/用python，查快递","loc":"https://weilet.github.io/用python，查快递"},{"title":"用crontab配置定时任务","text":"前段时间需要定期把一个服务器上的日志以邮件的形式发送到我的邮箱，于是了解了一下linux下定时任务的实现。 （本文假定阅读者有基本的linux操作能力） linux下一般用crontab配置定时任务，本人用的是centos。 安装命令如下： yum install vixie-cron #cron主程序 yum install crontab #crontab主体 chkconfig -level 345 crond on #设置开机自启动 安装成功后打开crontab 配置 vi /etc/crontab 然后 该文件布局如下（ 注意，以编辑crontab的方式运行定时任务不能省略用户名 ）： m h d m weekday user command 对应的分别是： 分钟 小时 日期 月份 星期 用户 命令 每个值的范围（不过不限制则为*） 0-59 0-23 1-31 1-12 0-6(0 = sunday) username command 下面举例： 比如我想要在每天0：00以root用户执行一个名为test.sh的脚本： 0 0 * * * root ./root/test.sh #假设先前已经给了执行权限 再比如每周六和周日以root用户执行一个名为img_crawl.py的爬虫： * * * * 0,6 root python /root/img_crawl.py 或者你想要每天10：50开始 每十分钟以root用户执行clear_ram.sh脚本： 50,0 10 * * * root ./root/clear_ram.sh 0-59/10 * * * * root ./root/clear_ram.sh 以上就是玩了三天crontab的总结啦\\~","tags":"linux","url":"https://weilet.github.io/用crontab配置定时任务","loc":"https://weilet.github.io/用crontab配置定时任务"},{"title":"忘记root的密码如何解决","text":"昨天教同学使用Ubuntu，他居然把密码给忘记了。于是便顺便了解了一下这方面的知识。 首先是在开机3秒内按下ESC键 然后就会出现一个菜单，选择进入恢复模式 （recovery mode） 进入恢复模式以后，启用root shell 将目录改为可写 mount -o rw,remount 查看home下的用户 ls /home 修改密码 passwd 输入两次密码（一次是确认）即修改完成 重启","tags":"linux","url":"https://weilet.github.io/忘记了ubuntu的root用户的密码如何解决","loc":"https://weilet.github.io/忘记了ubuntu的root用户的密码如何解决"},{"title":"用python给你女朋友写封信","text":"喜欢木心先生的《从前慢》，那种一辈子只够爱一个人的闲适，被今日快节奏的生活方式打破。 虽然今日邮件已然销声匿迹，但电子邮件的兴起给我们另一个选择。 若怀念木心，不妨静下心来，在键盘上诚诚恳恳敲击你想对她诉说的，不也浪漫？不也悠长？ 那么，如何用python写电子邮件呢？ 我们需要用到smtplib和email模块 我们从简单的开始，写一首情诗送给她 # -*- coding: utf-8 -*- # @Author: Lily_Sun # @Date: 2018-07-12 05:56:46 # @Last Modified by: Lily_Sun # @Last Modified time: 2018-07-13 13:29:09 import smtplib from email.mime.text import MIMEText #多媒体网际网路邮件延伸文本，即纯文本 text = \"醉过才知酒浓，爱过才知情重。 \\ n你定是我的诗 ， 恰似我如你的梦 。 \" mail_host = \"smtp.163.com\" # 设置服务器 mail_user = \"**********@163.com\" # 发送邮箱 mail_pass = \"*******\" # 邮箱校验码 非密码 receiver = \"*******@163.com\" # 接收邮箱 message = MIMEText ( text , 'plain' , 'utf-8' ) #构造MIMEText对象 message [ 'From' ] = '难忘你的' + '<' + mail_user + '>' message [ 'To' ] = '我难忘的' + '<' + receiver + '>' message [ 'Subject' ] = ' 月色真美 ' try : smtpObj = smtplib . SMTP_SSL ( mail_host , 465 ) #实例一个邮件传输对象 smtpObj . ehlo () #初始化到服务器的连接，类似于敲门的感觉 smtpObj . login ( mail_user , mail_pass ) print ( '登录成功！' ) smtpObj . sendmail ( mail_user , receiver , message . as_string ()) # 发送邮件 smtpObj . quit () # 邮件退出 print ( \"恭喜：邮件发送成功!\" ) except smtplib . SMTPException : print ( \"错误：无法发送邮件\" ) 快用这个脚本给你女朋友发电子邮件，让她开心一下吧。如果你有的话(●'◡'●) 【未完待续】","tags":"python","url":"https://weilet.github.io/用python给你女朋友写封信","loc":"https://weilet.github.io/用python给你女朋友写封信"},{"title":"我的第一只爬虫","text":"寒假的时候学习了一下Python的爬虫，并将豆瓣电影排行榜爬取了下来 \" ` {.EnlighterJSRAW enlighter-language=\"python\"} - - coding: utf-8 - - @Author: Lily_Sun @Date: 2018-01-12 05:18:40 @Last Modified by: Lily_Sun @Last Modified time: 2018-01-12 05:18:40 import re from urllib import request cnt = 1 url = \"https://movie.douban.com/chart\" req = request.Request(url) with request.urlopen(req) as f: data = f.read().decode(‘utf-8') reg_name = r' [] [\\n][\" \"] . [\\n][\" \"] (. )' list = (re.findall(reg_name,data)) print(\"rank\"+\"\\t\\t\"+\"name\") for x in list: print(cnt,end=\"\\t\\t\\t\") print(x) cnt = cnt + 1 \"` 整个过程其实就是折腾正则表达式，以至于我现在都不知道为什么要加个[]。（然而实践告诉我就是要这样的。） 主要用来urllib 和 re 模块。 先发送请求到网站，然后打开后以utf-8编码格式的提取内容，再用正则提取需要的信息，最后添加点样式，打表即可。","tags":"python","url":"https://weilet.github.io/我的第一只爬虫","loc":"https://weilet.github.io/我的第一只爬虫"},{"title":"快速幂和矩阵快速幂","text":"快速幂，顾名思义就是快速求幂的算法。原理如下： 假设求a的n次方，当n为偶数时，a的n次方可以由两个a的n/2次方相乘求得；当n为奇数时，a的n次方可以由两个a的n/2次方相乘的积再乘以a得到。 在实现中，运用位运算判断奇偶和乘除2（第一个想到的简直就是天才） #include <iostream> using namespace std ; double quick_pow ( double base , int degree ) { double ans = 1.0 ; while ( degree ) { if ( degree & 1 ) ans *= base ; base *= base ; degree >>= 1 ; } return ans ; } int main () { double a ; int b ; cin >> a >> b ; cout << quick_pow ( a , b ) << endl ; } 矩阵快速幂呢，则是把求幂的对象变成了矩阵，下面是一道经典应用。 #include <iostream> using namespace std ; int N = 10000 , n ; void Matrix ( int ( & a )[ 2 ][ 2 ], int b [ 2 ][ 2 ]){ int tmp [ 2 ][ 2 ] = { 0 }; for ( int i = 0 ; i < 2 ; ++ i ) for ( int j = 0 ; j < 2 ; ++ j ) for ( int k = 0 ; k < 2 ; ++ k ) tmp [ i ][ j ] = ( tmp [ i ][ j ] + a [ i ][ k ] * b [ k ][ j ]) % N ; for ( int i = 0 ; i < 2 ; ++ i ) for ( int j = 0 ; j < 2 ; ++ j ) a [ i ][ j ] = tmp [ i ][ j ]; } int main (){ while ( cin >> n && n !=- 1 ){ int temp [ 2 ][ 2 ] = { 1 , 1 , 1 , 0 }, cot [ 2 ][ 2 ] = { 1 , 0 , 0 , 1 }; while ( n ){ if ( n & 1 ) Matrix ( cot , temp ); Matrix ( temp , temp ); n /= 2 ; } cout << cot [ 0 ][ 1 ] << endl ; } } 这个 的应用就很考数学功底，知道原理就好。","tags":"algorithm","url":"https://weilet.github.io/快速幂和矩阵快速幂","loc":"https://weilet.github.io/快速幂和矩阵快速幂"},{"title":"图片隐写套路","text":"总结一些图片隐写术的套路 0x000 exif Windows下直接右键属性查看就好，有些题目会用Base64等方式加密，不过也就一梭子代码的问题。 Linux下用 identify -verbose filename 0x001 隐藏文件 文件的隐藏利用 shell copy /b 2.jpg+1.zip output.jpg 对于这类题目，用binwalk分析后用dd命令分解出来就好： dd if = filename of = filename skip = start_point_of_hidden_file bs = 1 0x010 LSB 修改 直接用stegsolve看通道，一般会隐藏二维码在其中。 0x011 查看其他信息 Windows下把图片拖进WinHex，缺少文件头的话补全。在文件结尾后有一段不明字符串，可以尝试解码。 拖进Stegsolve里查看附着的信息，有可能有ascii形式的Flag。 0x100 双图 目前做过的题目的解决方案是拖进stegsolve里边然后选择图片叠加。","tags":"others","url":"https://weilet.github.io/图片隐写套路","loc":"https://weilet.github.io/图片隐写套路"}]};