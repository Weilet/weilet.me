<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Weilet's Workshop - C&amp;CPP</title><link href="/" rel="alternate"></link><link href="/feeds/ccpp.atom.xml" rel="self"></link><id>/</id><updated>2019-10-25T18:17:00+08:00</updated><entry><title>C++内存泄漏的一些点</title><link href="/c%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%82%B9.html" rel="alternate"></link><published>2019-10-25T18:17:00+08:00</published><updated>2019-10-25T18:17:00+08:00</updated><author><name>PwnForWhat</name></author><id>tag:None,2019-10-25:/c内存泄漏的一些点.html</id><content type="html">&lt;blockquote&gt;
&lt;p&gt;C++的内存管理太难了&lt;/p&gt;
&lt;p&gt;——鲁迅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;基类析构函数为非virtual&lt;/h3&gt;
&lt;p&gt;基类的析构函数如果是非virtual的，那么上转型时，基类的析构函数不会被覆盖。这样子，属于子类的部分在析构时就不会会删除，导致内存泄漏。&lt;/p&gt;
&lt;h3&gt;依赖用户释放对象&lt;/h3&gt;
&lt;p&gt;依赖用户使用delete来释放内存，如果在释放过程前抛出异常，那么这部分的内存就不会被释放，导致内存泄漏。&lt;/p&gt;
&lt;p&gt;一个足够鲁棒的做法是，返回一个shared_ptr来管理原生对象。shared_ptr是个神奇的玩意，但你记得要为对象创建合适的shared_ptr。&lt;/p&gt;
&lt;h3&gt;New 和 Delete 不对称&lt;/h3&gt;
&lt;p&gt;New 一组对象，却只delete一个对象，这样不内存泄漏真的没天理&lt;/p&gt;
&lt;h3&gt;未定义复制构造函数而成员中有指针变量&lt;/h3&gt;
&lt;p&gt;这会导致调用默认复制构造函数然后使得同一个地址被两个指针所指（复制和被复制对象的指针变量），导致同一位置的内存被释放两次。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你以为大家看不出这是《effective C++》的书摘吗?&lt;/p&gt;
&lt;/blockquote&gt;</content><category term="C&amp;amp;CPP"></category></entry><entry><title>C 语言中的 extern 关键字</title><link href="/c-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84-extern-%E5%85%B3%E9%94%AE%E5%AD%97.html" rel="alternate"></link><published>2019-05-06T15:48:00+08:00</published><updated>2019-05-06T15:48:00+08:00</updated><author><name>PwnForWhat</name></author><id>tag:None,2019-05-06:/c-语言中的-extern-关键字.html</id><summary type="html">&lt;blockquote&gt;
&lt;p&gt;如果不是选择重新学习 C，我可能这辈子都不会碰到这个关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;extern 用于声明一个外部变量，这个变量在项目的其他地方定义过。&lt;/p&gt;
&lt;p&gt;假设有头文件 errno.h&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 test.c 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;errno.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 声明外部变量&lt;/span&gt;
      &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 可以对外部变量进一步操作&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      一些操作&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的点是，如果你使用不止一个外部变量，你应当保证它们的名字都不一样。（不要试图仅凭类型区分两个外部变量！！！）&lt;/p&gt;
&lt;p&gt;在声明外部变量时，一般避免直接定义，即不要写成 &lt;strong&gt;extern int a = 0;&lt;/strong&gt; 的形式。&lt;/p&gt;
&lt;p&gt;这样的变量不能进一步修改，不能循环利用，出于环保的缘故我们应当趋避之 …&lt;/p&gt;</summary><content type="html">&lt;blockquote&gt;
&lt;p&gt;如果不是选择重新学习 C，我可能这辈子都不会碰到这个关键字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;extern 用于声明一个外部变量，这个变量在项目的其他地方定义过。&lt;/p&gt;
&lt;p&gt;假设有头文件 errno.h&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在 test.c 中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;errno.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 声明外部变量&lt;/span&gt;
      &lt;span class="n"&gt;errno&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 可以对外部变量进一步操作&lt;/span&gt;
      &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;      一些操作&lt;/span&gt;
&lt;span class="cm"&gt;      */&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要注意的点是，如果你使用不止一个外部变量，你应当保证它们的名字都不一样。（不要试图仅凭类型区分两个外部变量！！！）&lt;/p&gt;
&lt;p&gt;在声明外部变量时，一般避免直接定义，即不要写成 &lt;strong&gt;extern int a = 0;&lt;/strong&gt; 的形式。&lt;/p&gt;
&lt;p&gt;这样的变量不能进一步修改，不能循环利用，出于环保的缘故我们应当趋避之。&lt;/p&gt;</content><category term="C&amp;amp;CPP"></category></entry><entry><title>宏定义的常见的三种意外</title><link href="/%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%84%8F%E5%A4%96.html" rel="alternate"></link><published>2019-04-30T16:20:00+08:00</published><updated>2019-04-30T16:20:00+08:00</updated><author><name>PwnForWhat</name></author><id>tag:None,2019-04-30:/宏定义的常见的三种意外.html</id><summary type="html">&lt;h4&gt;宏拓展后的大小可能超乎你的想象&lt;/h4&gt;
&lt;p&gt;这一点没想到例子，以后碰到再补充&lt;/p&gt;
&lt;h4&gt;对参数的捆绑不如函数严实，会导致意料之外的结果&lt;/h4&gt;
&lt;p&gt;很常见的一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define square(x) x*x&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编写一个宏，计算 x 的平方。&lt;/p&gt;
&lt;p&gt;看上去这段代码没有错，我们得到的答案将会是 25。&lt;/p&gt;
&lt;p&gt;实际上呢，我们得到的答案是 11。&lt;/p&gt;
&lt;p&gt;为什么呢？我们将square(x+1)展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1 …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h4&gt;宏拓展后的大小可能超乎你的想象&lt;/h4&gt;
&lt;p&gt;这一点没想到例子，以后碰到再补充&lt;/p&gt;
&lt;h4&gt;对参数的捆绑不如函数严实，会导致意料之外的结果&lt;/h4&gt;
&lt;p&gt;很常见的一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define square(x) x*x&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;square&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编写一个宏，计算 x 的平方。&lt;/p&gt;
&lt;p&gt;看上去这段代码没有错，我们得到的答案将会是 25。&lt;/p&gt;
&lt;p&gt;实际上呢，我们得到的答案是 11。&lt;/p&gt;
&lt;p&gt;为什么呢？我们将square(x+1)展开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了避免这种问题，我们应当考虑到宏展开后参数的实际形式。&lt;/p&gt;
&lt;h4&gt;带有副作用的参数，可能执行次数与预期不同，导致意料之外的结果。&lt;/h4&gt;
&lt;p&gt;考虑这样的一段代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define MIN(A,B) ((A) &amp;lt; (B) ? (A) : (B))&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%f&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MIN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%f&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看上去 ，这又是一段没有问题的代码，如果我们输入 1，结果应当是1。&lt;/p&gt;
&lt;p&gt;事实上呢？我们会发现返回的结果是 2。&lt;/p&gt;
&lt;p&gt;展开一下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;float&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;x在这段宏的执行中，值改变了两次。在比较a++和1.5的时候，先取1和1.5比较，然后a自增1。接下来条件比较得到真以后又触发了一次a++，此时a已经是2，于是b得到2，最后a再次自增后值为3。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你应当尽量减少在宏中使用带副作用的参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考了这个博客：&lt;br&gt;
&lt;a href="https://onevcat.com/2014/01/black-magic-in-macro/"&gt;https://onevcat.com/2014/01/black-magic-in-macro/&lt;/a&gt;&lt;/p&gt;</content><category term="C&amp;amp;CPP"></category></entry><entry><title>C 语言下多重嵌套的define</title><link href="/c-%E8%AF%AD%E8%A8%80%E4%B8%8B%E5%A4%9A%E9%87%8D%E5%B5%8C%E5%A5%97%E7%9A%84define.html" rel="alternate"></link><published>2019-04-28T13:47:00+08:00</published><updated>2019-04-28T13:47:00+08:00</updated><author><name>PwnForWhat</name></author><id>tag:None,2019-04-28:/c-语言下多重嵌套的define.html</id><summary type="html">&lt;p&gt;有以下一段宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _STR(x) _VAL(x)&lt;/span&gt;
&lt;span class="cp"&gt;#define _VAL(x) #x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原以为只是 define _VAL(x) #x 起效果，并不清楚 define _STR(x) _VAL(x) 的作用。&lt;/p&gt;
&lt;p&gt;因为使用 int x = 5 去测试，发现无论是 _STR() 还是 _VAL() 都是输出 x&lt;/p&gt;
&lt;p&gt;后来发现，如果改为在顶部添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define x 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;_STR() 的值为 "100" 而 _VAL()的值为 "x"&lt;/p&gt;
&lt;p&gt;由此可以得知，所谓的 define _STR …&lt;/p&gt;</summary><content type="html">&lt;p&gt;有以下一段宏：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define _STR(x) _VAL(x)&lt;/span&gt;
&lt;span class="cp"&gt;#define _VAL(x) #x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原以为只是 define _VAL(x) #x 起效果，并不清楚 define _STR(x) _VAL(x) 的作用。&lt;/p&gt;
&lt;p&gt;因为使用 int x = 5 去测试，发现无论是 _STR() 还是 _VAL() 都是输出 x&lt;/p&gt;
&lt;p&gt;后来发现，如果改为在顶部添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define x 100&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;_STR() 的值为 "100" 而 _VAL()的值为 "x"&lt;/p&gt;
&lt;p&gt;由此可以得知，所谓的 define _STR(x) _VAL(x) 用于获取十进制常量的意思，就是获取参数在define时的值（而非赋值操作的值），进而通过 #x 转换为字符串量。&lt;/p&gt;
&lt;p&gt;最后，附上测试的代码，你可以自行验证：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define t 100&lt;/span&gt;
&lt;span class="cp"&gt;#define _STR(x) _VAL(x)&lt;/span&gt;
&lt;span class="cp"&gt;#define _VAL(x) #x&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_STR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;+&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="C&amp;amp;CPP"></category></entry><entry><title>良性取消定义</title><link href="/%E8%89%AF%E6%80%A7%E5%8F%96%E6%B6%88%E5%AE%9A%E4%B9%89.html" rel="alternate"></link><published>2019-04-27T22:45:00+08:00</published><updated>2019-04-27T22:45:00+08:00</updated><author><name>PwnForWhat</name></author><id>tag:None,2019-04-27:/良性取消定义.html</id><content type="html">&lt;p&gt;在 C 标准库里面，\&amp;lt;assert.h&gt; 中有一段这样的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#undef assert&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef NDEBUG&lt;/span&gt;
&lt;span class="cp"&gt;#define assert (test) ((void)0)&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="cp"&gt;#define assert (test) ...&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里面第一行就是 &lt;strong&gt;良性取消定义&lt;/strong&gt;，它是用来保证先前已经 define 的 assert 不会影响接下来的 assert。如果先前没有 define assert，那么这个语句也不会产生任何副作用。当使用一些可变的定义时，&lt;strong&gt;良性取消定义&lt;/strong&gt;是必要的。&lt;/p&gt;</content><category term="C&amp;amp;CPP"></category></entry></feed>